---
navbar: true
sidebar: auto
title: 章节8.聊天通讯
---

## 一、连接即时通讯websocket
### 1. 在初始化登录的时候链接
关于websocket的链接，`uni-app`官网：<https://uniapp.dcloud.net.cn/api/request/websocket.html> <br/>
在 `/store/modules/chatuser.js`文件
```js
import {requestUrl} from '@/common/mixins/configData.js';
export default {
	// 对应的mapState,在computed中引用导入
	// 类似于data,把全局或者公共部分放在这里
	state: {
		...
	},
	// 异步的方法，在methods引入
	actions: {
		//注册登录后续的操作
		...,
		// 用户退出登录
		...,
		// 初始化登录注册状态（避免刷新页面state没有数据）
		initChatuserAction({commit,state,dispatch}) {
			console.log('初始化登录注册状态', state);
			// 给state赋值
			let user = uni.getStorageSync('chatuser') ?
				JSON.parse(uni.getStorageSync('chatuser')) : '';
			if (user) {
				state.regloginUser = user;
				console.log('初始化登录注册状态', state);
				//获取好友申请的信息
				dispatch('getGoodfriendapply');
				// 连接websocket服务
				dispatch('connectWebsocket',user);
			}
		},
		//获取好友申请的信息
		...,
		// 获取好友列表
		...,
		// 连接websocket服务
		connectWebsocket({commit,state,dispatch}, payload = {}){
			// 链接即时通讯websocket
			let chatSocket = uni.connectSocket({
				//http://192.168.2.7:7001
				//ws://192.168.2.7:7001/ws
				url: 'ws' + requestUrl.http.replace('http','').replace('s','') + `/ws?
                token=${payload.token}`,
				complete: () => {},
				timeout: 10000 // 10秒超时
			});
			// 心跳
			let heartbeatTimer = null;
			//链接成功
			chatSocket.onOpen(() => {
			    console.log('websocket链接成功');
			  
			    // 启动心跳
				heartbeatTimer = setInterval(() => {
					if (chatSocket && chatSocket.readyState === 1) {
					  chatSocket.send(JSON.stringify({ type: 'ping' }));
					}
				}, 25000); // 每25秒发送一次心跳
			});
			// 接收信息
			chatSocket.onMessage(res => {
				// 处理不同平台的消息格式
				try {
					const data = typeof res.data === 'string' 
						? JSON.parse(res.data) 
						: res.data;
						
					console.log('websocket接收信息', data);
				
					if (data.type === 'ping') {
						// 响应心跳
						chatSocket.send(JSON.stringify({ type: 'pong' }));
					}
				} catch (e) {
					console.error('消息解析错误', e);
				}
			});
			// 断开连接
			chatSocket.onClose((res) => {
			    console.log('断开连接原因:', res);
			    clearInterval(heartbeatTimer); // 清除心跳
				heartbeatTimer = null;
			  
			    // 尝试重新连接
				setTimeout(() => {
					console.log('尝试重新连接 WebSocket');
					dispatch('initChatuserAction');
				}, 3000);
			});
			// 错误处理
			chatSocket.onError(err => {
				console.error('WebSocket 错误:', err);
				clearInterval(heartbeatTimer);
				heartbeatTimer = null;
				setTimeout(() => {
					console.log('错误处理尝试重新连接 WebSocket');
					dispatch('initChatuserAction');
				}, 5000);
			});
		},
	},
}
```

### 2. 调用类的形式执行websocket
我们可以编写一个类来调用websocket，方便我们后期扩展
### 1. 新建js类文件： `/common/js/chatClass.js`
```js
import {requestUrl} from '@/common/mixins/configData.js';
class chatClass {
	//构造函数
	constructor(){
		// ws地址
		this.url = '';
		if(requestUrl.http.startsWith('http')){
			this.url = 'ws' + requestUrl.http.replace('http','');
		}else if(requestUrl.http.startsWith('https')){
			this.url = 'wss' + requestUrl.http.replace('https','');
		}
		// 是否上线
		this.isOnline = false;
		// socketTask 对象
		this.chatSocket = null;
		// 我的信息vuex或者本地获取
		const user = uni.getStorageSync('chatuser') ?
		JSON.parse(uni.getStorageSync('chatuser')) : '';
		this.user = user;
		// 连接websocket
		if(this.user && this.user.token){
			this.connectSocket();
		}
		// 心跳
		this.heartbeatTimer = null;
	}
	// 连接websocket
	connectSocket(){
		// 链接即时通讯websocket
		this.chatSocket = uni.connectSocket({
			//http://192.168.2.7:7001
			//ws://192.168.2.7:7001/ws
			url: this.url + `/ws?token=${this.user.token}`,
			complete: () => {},
			timeout: 10000 // 10秒超时
		});
		// 心跳
		//let heartbeatTimer;
		//链接成功
		this.chatSocket.onOpen(() => {
		    console.log('websocket链接成功');
		  
		    // 启动心跳
			this.heartbeatTimer = setInterval(() => {
				//（跨平台兼容）小程序环境中没有 WebSocket.OPEN，使用数字 1 表示 OPEN 状态
				if (this.chatSocket && this.chatSocket.readyState === 1) {
				  this.chatSocket.send(JSON.stringify({ type: 'ping' }));
				}
			}, 25000); // 每25秒发送一次心跳
		});
		// 接收信息
		this.chatSocket.onMessage(res => {
			// 处理不同平台的消息格式
		    try {
			    const data = typeof res.data === 'string' 
					? JSON.parse(res.data) 
					: res.data;
					
				console.log('websocket接收信息', data);
			
			    if (data.type === 'ping') {
					// 响应心跳
					this.chatSocket.send(JSON.stringify({ type: 'pong' }));
				}
		    } catch (e) {
			    console.error('消息解析错误', e);
		    }
		});
		// 断开连接
		this.chatSocket.onClose((res) => {
		    console.log('断开连接原因:', res);
		    clearInterval(this.heartbeatTimer); // 清除心跳
		    this.heartbeatTimer = null;
		  
		    // 尝试重新连接
			setTimeout(() => {
				console.log('尝试重新连接 WebSocket');
				//dispatch('initChatuserAction');
				this.connectSocket();
			}, 3000);
		});
		// 错误处理
		this.chatSocket.onError(err => {
			console.error('WebSocket 错误:', err);
			clearInterval(this.heartbeatTimer);
			this.heartbeatTimer = null;
			setTimeout(() => this.connectSocket(), 5000);
		});
	}
}

export default chatClass;
```

### 2. 在vuex中调用
在 `/store/modules/chatuser.js` 中代码
```js
...
import chatClass  from '@/common/js/chatClass.js';
export default {
	// 对应的mapState,在computed中引用导入
	// 类似于data,把全局或者公共部分放在这里
	state: {
		...
	},
	// 异步的方法，在methods引入
	actions: {
		//注册登录后续的操作
		...,
		// 用户退出登录
		...,
		// 初始化登录注册状态（避免刷新页面state没有数据）
		initChatuserAction({commit,state,dispatch}) {
			console.log('初始化登录注册状态', state);
			// 给state赋值
			let user = uni.getStorageSync('chatuser') ?
				JSON.parse(uni.getStorageSync('chatuser')) : '';
			if (user) {
				state.regloginUser = user;
				console.log('初始化登录注册状态', state);
				//获取好友申请的信息
				dispatch('getGoodfriendapply');
				// 连接websocket服务
				// dispatch('connectWebsocket',user);
				// 实例化后自动执行构造函数
				new chatClass(); 
			}
		},
		//获取好友申请的信息
		...,
		// 获取好友列表
		...,
		// 连接websocket服务
		connectWebsocket({commit,state,dispatch}, payload = {}){
			...
		},
	},
}
```


## 二、通讯录好友列表进入聊天页
### 1. 聊天类扩展几个方法
在文件 `/common/js/chatClass.js`
```js
import {requestUrl} from '@/common/mixins/configData.js';
class chatClass {
	// 构造函数
	constructor() {
	    // ws地址
		this.url = '';
		if(requestUrl.http.startsWith('http')){
			this.url = 'ws' + requestUrl.http.replace('http','');
		}else if(requestUrl.http.startsWith('https')){
			this.url = 'wss' + requestUrl.http.replace('https','');
		}
		// 是否上线
		this.isOnline = false;
		// socketTask对象
		this.chatSocket = null;
		// 我的信息 vuex 或者从本地获取
		let user = uni.getStorageSync('chatuser') ?
			JSON.parse(uni.getStorageSync('chatuser')) : '';
		this.user = user;
		// 连接websocket
		if(this.user && this.user.token){
			this.connectSocket();
		}
		// 心跳
		this.heartbeatTimer = null;
	}
	
	// 连接websocket
	connectSocket(){
		this.chatSocket = uni.connectSocket({
			// http://192.168.2.7:7001
			// ws://192.168.2.7:7001/ws
			// https://lesson07.51yrc.com
			// wss://lesson07.51yrc.com/ws
			url: this.url + `/ws?token=${this.user.token}`,
			complete: ()=> {},
			timeout:10000, // 10秒超时
		});
		
		// 连接成功
		this.chatSocket.onOpen(()=>{
			console.log('websocket连接成功');
			//调用方法
			this.onOpen();
			//启动心跳
			this.heartbeatTimer = setInterval(()=>{
				if(this.chatSocket && this.chatSocket.readyState === 1){
					this.chatSocket.send(JSON.stringify({type:'ping'}));
				}
			},25000); // 每隔25秒发送一次心跳
		});
		// 接收信息
		this.chatSocket.onMessage(res=>{
			// 处理一下不同平台消息格式
			try{
				const data = typeof res.data === 'string' ?
				JSON.parse(res.data) : res.data;
				
				this.onMessage(data);
				
				if(data.type === 'ping'){
					// 响应心跳
					this.chatSocket.send(JSON.stringify({type:'pong'}));
				}
			}catch(e){
				console.error('接收信息错误',e);
			}
		});
		// 断开连接
		this.chatSocket.onClose(res=>{
			console.log('断开连接的原因', res);
			clearInterval(this.heartbeatTimer); // 清除心跳
			this.heartbeatTimer = null;
			// 调用方法
			this.onClose();
			// 尝试重新连接
			setTimeout(()=>{
				console.log('断开连接尝试重新连接websocket');
				//dispatch('initChatuserAction');
				this.connectSocket();
			},3000);
		});
		// 错误处理
		this.chatSocket.onError(err=>{
			console.error('websocket 错误：', err);
			clearInterval(this.heartbeatTimer); // 清除心跳
			this.heartbeatTimer = null;
			// 尝试重新连接
			setTimeout(()=>{
				console.log('错误处理尝试重新连接websocket');
				//dispatch('initChatuserAction');
				this.connectSocket();
			},5000);
		});
	}
	
	// 连接成功
	onOpen(){
		// 上线用户
		this.isOnline = true;
	}
	// 断开连接
	onClose(){
		// 下线用户
		this.isOnline = false;
		this.chatSocket = null;
	}
	// 接收信息
	onMessage(data){
		console.log('websocket接收信息',data);
	}
	
	// 关闭链接
	close(){
		// 用户退出关闭链接
		// 调用socketTask 对象的close方法
		this.chatSocket.close();
	}
}

export default chatClass;
```

### 2. vuex中调用
在文件 `/store/modules/chatuser.js`
```js
...
export default {
	// 对应的mapState,在computed中引用导入
	// 类似于data,把全局或者公共部分放在这里
	state: {
		...
		// 聊天类
		chatClass:null,
	},
	// 异步的方法，在methods引入
	actions: {
		//注册登录后续的操作
		regloginAction({commit,state,dispatch}, regloginRes) {
			...
			//获取好友申请的信息
			...
			//连接websocket服务
			//dispatch('connectWebsocket',state.regloginUser);
			state.chatClass = new chatClass();
		},
		// 用户退出登录
		logoutAction({commit,state}) {
			//关闭链接websocket
			state.chatClass.close();
			state.chatClass = null;
			//清空用户信息
			...
			// 删除本地存储
			...
		},
		// 初始化登录注册状态（避免刷新页面state没有数据）
		initChatuserAction({commit,state,dispatch}) {
			console.log('初始化登录注册状态', state);
			// 给state赋值
			...
			if (user) {
				...
				//连接websocket服务
				//dispatch('connectWebsocket',user);
				state.chatClass = new chatClass();
			}
		},
		//获取好友申请的信息
		...,
		// 获取好友列表
		...,
		
	},
}
```

### 3. 先从我的好友列表（通讯录）进入聊天
在页面 `/pages/userinfo/userinfo.vue`
```js
//发消息
sendMessageFun(){
	console.log('发消息的逻辑',this.me);
	if(this.me.ismygoodfriend){
		console.log('是我的朋友，可以直接聊天了',this.user);
		// 进入聊天页，传一些用户数据过去在页面展示
		const userchat = {
			id: this.user.id,
			name: this.user.nickname || this.user.username,
			avatar: this.user.avatar,
			chatType: 'single' , // 单聊 single 群聊 group
		};
		uni.navigateTo({
			url: `/pages/chat/chat?arg=${encodeURIComponent(JSON.stringify(userchat))}`,
		});
	}else{
		...
	}
},
```

### 4. 聊天页面初始判断
在页面 `/pages/chat/chat.nvue`
```js
data() {
	return {
		...
		// 页面参数
		arg:null,
	}
},
onLoad(e) {
	if(!e.arg || !this.me) return this.navigateBack();
	let arg = decodeURIComponent(e.arg);
	try{
		this.arg = JSON.parse(arg);
		console.log('聊天页参数',this.arg);
	}catch{
		return this.navigateBack();
	}
},
computed:{
	...mapState({
		...,
		me : state => state.Chatuser.regloginUser,
	}),
},
```


## 三、创建和销毁聊天对象消息及给服务器发消息测试
课后把后台`是不是我的好友`的返回结果调整了一下，由`goodfriend` 改成了 好友信息，具体：<a href="/fourthless/w-a/eggjs.即时通讯接口.html#十九、查询一下对方是否是我的好友">十九、查询一下对方是否是我的好友</a> <br/>

### 1. 重新处理用户信息昵称显示
在页面 `/pages/userinfo/userinfo.vue`
```js
// 是不是我的好友
ismygoodfriend(){
	uni.$u.http.post(requestUrl.http + `/api/chat/ismygoodfriend/${this.user.id}`,{},{
		header:{
			token:uni.getStorageSync('chatuser_token'),
		}
	}).then(res => {
			console.log('是不是我的好友',res);
			if(res.data.msg == 'ok') {
				this.me.ismygoodfriend = res.data.data;
				this.user.nickname = res.data.data.nickname;
				uni.setNavigationBarTitle({
				   title: this.user.nickname || this.user.username,
				});
			}
	}).catch(err => {
		this.me.ismygoodfriend = false;
	});
},
```

### 2. 聊天类创建聊天对象及发消息到服务器
给服务器发消息（单聊）（发送消息给对方）的接口说明：<a href="/fourthless/w-a/eggjs.即时通讯接口.html#二十、给服务器发消息-单聊-发送消息给对方" target="_blank">二十、给服务器发消息（单聊）（发送消息给对方）</a> <br/>
在文件 `/common/js/chatClass.js`
```js
import {requestUrl} from '@/common/mixins/configData.js';
class chatClass {
	// 构造函数
	constructor() {
	    ...
		// 聊天对象信息
		this.ToObject = false;
	}
	
	// 连接websocket
	...
	
	// 连接成功
	...
	
	// 断开连接
	...
	
	// 接收信息
	...
	
	// 关闭链接
	...
	
	// 创建聊天对象信息
	createChatToObject(arg){
		this.ToObject = arg;
		console.log('创建聊天对象信息',this.ToObject);
	}
	
	// 销毁聊天对象信息
	destroyChatToObject(){
		this.ToObject = false;
	}
	
	// 发送消息
	sendmessage(msg){
		return new Promise((result,reject)=>{
			uni.$u.http.post(requestUrl.http + `/api/chat/socket/sendmessage`,{
				sendto_id: this.ToObject.id,
				chatType: this.ToObject.chatType,// 单聊 single 群聊 group
				type: msg.type,
				data: msg.data,
			},{
			    header:{
				    token:uni.getStorageSync('chatuser_token'),
			    }
			}).then(res => {
				 console.log('发送消息结果', res);
				 result(res);
			}).catch(err =>{
				console.log('发送消息失败', err);
				reject(err);
			});
		});
	}
}

export default chatClass;
```


### 3.在聊天页创建和销毁聊天对象信息
在页面 `/pages/chat/chat.nvue`
```js
onLoad(e) {
	if(!e.arg) return this.navigateBack();
	let arg = decodeURIComponent(e.arg);
	try{
		this.arg = JSON.parse(arg);
		console.log('聊天页参数对象',this.arg);
		// 创建聊天对象信息
		this.chatClass.createChatToObject(this.arg);
	}catch{
		return this.navigateBack();
	}
},
destroyed() {
	// 销毁聊天对象信息
	this.chatClass.destroyChatToObject();
},
computed:{
	...mapState({
		...,
		chatClass:state=>state.Chatuser.chatClass,
	}),
},
```

### 4. 给服务器发消息（单聊）（发送消息给对方）测试
给服务器发消息（单聊）（发送消息给对方）的接口说明：<a href="/fourthless/w-a/eggjs.即时通讯接口.html#二十、给服务器发消息-单聊-发送消息给对方" target="_blank">二十、给服务器发消息（单聊）（发送消息给对方）</a> <br/>
在文件 `/pages/chat/plusIconAction.js`
```js
//发送消息
sendMessage(msgType, option = {}){
	//向服务器发消息
	this.chatClass.sendmessage({
		type: msgType,
		data: this.messageValue, // 测试发送文字
	}).then(res => {
		console.log('页面获取服务器返回结果', res);
	}).catch(err => {
		console.log('页面获取服务器失败结果', err);
	});
	
	return;
	console.log('发送消息',msgType);
	...
}
```





















