---
navbar: true
sidebar: auto
title: 章节9.聊天页撤回转发消息等功能实现
---

## 一、撤回消息功能实现
### 1. 页面渲染数据赋值改动
在文件 `/pages/chat/plusIconAction.js`
```js
...
//发送消息
sendMessage(msgType, option = {}){
    return new Promise((resolve,reject) =>{
        console.log('发送消息',msgType);
        ...
        // 组织一下消息格式和服务器一致
        ...
        // console.log('发消息格式数据',serverMsg); return;
        // 显示到页面上
        msg.avatar = serverMsg.from_avatar.startsWith('/') ? 
                        requestUrl.http + serverMsg.from_avatar : serverMsg.from_avatar ;            
        msg.nickname = serverMsg.from_name;
        msg.user_id = serverMsg.from_id;
        // 直接渲染到页面的msg信息重新赋值一下
        msg = {...serverMsg, ...msg};
        console.log('----直接渲染到页面的msg信息重新赋值一下---', msg);
        // 发送消息的状态
        // msg.sendStatus = 'pending';
        // 拿到要发送消息的索引
        let sendmsgIndex = -1;
        if(msg.previewFileIndex != undefined && msg.previewFileIndex != -1){
            // 如果是预览数据则替换预览数据
            ...
            // 替换的数据
            ...
        }else{
            ...
        }
        // 发给服务器消息
        if(msg.isSendToServer){
            console.log('发消息给服务器的数据', serverMsg);
            this.chatClass.sendmessage(serverMsg).then(result => {
                console.log('页面接收服务器返回结果',result);
                // 拿到刚发送的消息赋值
                ...
                // 执行后续操作
                ...
            }).catch(error => {
                ...
            });
        }else{
           ...
        }
        // 清空发送的内容然后还要滚动到底部
        ...
    });

},
...		
```


### 2. 撤回消息服务器交互
在组件 `/components/chat-item/chat-item.vue`中
```vue
<template>
	<view class="px-3">
		<!-- 时间 -->
		...
		<!-- 撤回消息 -->
		<view v-if="item.isremove"
		class="flex align-center justify-center py-3">
			<text class="font-sm text-light-muted">{{ isMe ? '您' : item.nickname}}撤回了一条信息</text>
		</view>
		<!-- 进群首条消息提示 -->
		...
		<!-- 聊天内容 -->
		...
	</view>
</template>

<script>
    ...
	export default{
		...,
		methods:{
			...,
			clickType(e) {
				console.log('点击菜单',e);
				switch (e){
					case 'copy':
						break;
					case 'removeChatItem':
					    console.log('撤回消息', this.item);
						this.chatClass.revokeChatInfo(this.item).then((res)=>{
							// 自己的聊天页消息撤回
							this.item.isremove = true;
							// 消息页显示处理
							console.log('看一下撤回消息服务器返回的结果',res);
							// 重点注意：消息页的id单聊是聊天用户id,群聊是群id
							// 对应到res里面的是to_id
							res.id = res.to_id;
							// 消息页的聊天列表更新一下
							this.chatClass.updateXiaoXiList(res);
						});
						break;
				}
				this.$refs.chatTooltip.hide();
			},
			...
		}
	}
</script>

```

### 3. 撤回消息服务器方法
在类文件 `/common/js/chatClass.js`
```js
    ...
    // 处理接收到的消息
	async doMessage(msg){
		console.log('处理接收到的消息',msg);
		if(msg.type == 'system'){
			console.log('系统消息单独处理');
		}else if(msg.type == 'singleChat'){
			let msgData = msg.data;
			if(msgData.actionType && msgData.actionType == 'revoke'){
				// 撤回处理
				// 获取历史记录, 传key值则找指定聊天记录
				// 不传key则构建一个聊天对象因为对方可能不在聊天页
				// this.ToObject.chatType = msgData.chatType;
				// this.ToObject.id = msgData.chatType == 'single' ? msgData.from_id : msgData.to_id; //接收人|群id 
				let keyId = msgData.chatType == 'single' ? msgData.from_id : msgData.to_id; //接收人|群id
				// 因为this.ToObject初始化默认false,无法赋值，所以我们直接传key
				let key = `chatDetail_${this.user.id}_${msgData.chatType}_${keyId}`;
				let chatInfoList = this.getChatInfo(key);
				console.log('----撤回处理获取所有历史记录----',chatInfoList);
				// 根据id找到要撤回的消息
				let index = chatInfoList.findIndex(v => v.id == msgData.id);
				if(index != -1){
					// 找到了
					let revokeMsg = chatInfoList[index];
					console.log('----找到了要撤回的消息历史记录----', revokeMsg);
					revokeMsg.isremove = 1;
					// 找到k属性
					let k = revokeMsg.k;
					// 更新指定的历史记录信息(不急着更新可以异步)
					await this.updateChatInfo(revokeMsg, k, false);
					// 消息页列表要不要更新：取决于撤回的消息是不是最新的消息
					if(chatInfoList.length - 1 == index){
						// 是最新的消息
						// 消息页修改data 和 type
						revokeMsg.data = msgData.data;
						revokeMsg.type = msgData.type;
						revokeMsg.update_time = (new Date()).getTime();
						// 消息页的聊天列表更新一下
						this.updateXiaoXiList(revokeMsg, false);
						// 全局通知数据--聊天页做更新
					}else{
						// 不是最新消息
						// 全局通知数据--聊天页做更新
					}
					// 全局通知数据--聊天页做更新
					uni.$emit('onMessage', {
						actionType: msgData.actionType,
						...revokeMsg,
					});
				}
			}else{
				// 把聊天信息存在本地
				let { data } = this.addChatInfo(msgData, false);
				// 消息页的聊天列表更新一下
				this.updateXiaoXiList(data, false);
				// 全局通知数据
				uni.$emit('onMessage', data);
			}
		}
	}
    ...
    // 撤回消息(包括跟个人或者群聊天的某条自己发送的消息)
	revokeChatInfo(options){
		return new Promise((resolve,reject)=>{
			uni.$u.http.post(requestUrl.http + `/api/chat/revokeMessage`, {
				to_id: options.to_id,
				to_name: options.to_name,
				to_avatar: options.to_avatar,
				id: options.id,
				chatType: options.chatType,
				create_time: options.create_time,
			}, {
				header: {
					token: this.user.token,
				},
			}).then(res => {
				console.log('服务器撤回消息', res);
				// 删除（与某个群所有或者某条聊天信息，与某个人的所有或者某条聊天信息）
				this.clearChatInfo(options.to_id, options.chatType, options.id)
				.then(()=>{
					console.log('撤回消息已完成我自己页面消息的撤回效果');
					resolve(res.data.data);
				});
			}).catch(err => {
				console.log('服务器撤回消息失败', err);
				uni.showToast({title: err.data.data, icon:'none'});
				reject(err);
			});
		});
	}
	
```

### 4. 撤回消息服务器方法接口说明
接口说明具体查看：<a href="/fourthless/w-a/eggjs.即时通讯接口.html#三十二、撤回消息接口说明" target="_blank">三十二、撤回消息接口说明</a>

### 5. 通过websocket撤回消息的用户处理
在页面 `/pages/chat/chat.nvue`
```js
onLoad(e) {
    ...
    try{
        ...
        // 监听处理接收到的消息
        uni.$on('onMessage', v => {
            console.log('-----监听处理接收到的消息在聊天页------',v);	
            if((v.from_id == this.arg.id && v.chatType == 'single') ||
            (v.chatType == 'group' && this.arg.id == v.to_id)){
                if(v.actionType && v.actionType == 'revoke'){
                    // 撤回处理
                    let index = this.chatDataList.findIndex(e => e.id == v.id);
                    if(index != -1){
                        console.log('找到撤回的消息index', index);
                        this.chatDataList[index].isremove = 1;
                    }
                }else{
                    // 正常接收显示
                    this.chatDataList.push(this.formatServerMsg(v));
                }
            }
        });
        
    }catch{
        ...
    }
},
methods: {
	...
	// 接收的或者历史记录格式化成需要的聊天数据属性渲染页面
	formatServerMsg(v){
		...
		// 渲染到聊天页的数据
		let chatdata = {
			...v,
			...
			type: v.type, //image,video
			isremove: v.isremove,
			...
		};
		console.log('接收的或者历史记录渲染到页面的最终数据', chatdata);
		return chatdata;
	},
```

### 6. 消息页处理
在组件 `/components/chat-chatlist/chat-chatlist.vue`
```js
computed:{
    ...
    // 昵称下面的小字
    showText(){
        if(this.item.type == 'text'){
            // 纯文字 和 头像文字
            if(typeof this.item.data == 'string'){
                return this.item.datadesc + this.item.data;
            }else if(typeof this.item.data == 'object'){
                return this.item.datadesc + this.item.data.data;
            }
        }else if(this.item.type == 'systemNotice'){
            let data = ``;
            if(typeof this.item.data == 'string'){
                data = this.item.data;
            }else if(typeof this.item.data == 'object'){
                data = this.item.data.data;
            }
            let mynickname = this.me.nickname || this.me.username;
            console.log('计算属性看一下我的昵称',mynickname);
            console.log('计算属性看一下data', data);
            if(data.indexOf(mynickname) > -1){
                data = data.replace(mynickname, '您');
            }
            return data;
        }else{
            return this.item.datadesc;
        }
    },
}
```


## 二、删除聊天页某条消息功能实现
说明：
1. 我们把`撤回消息`和`删除消息`一起讲，主要是为了让大家理解两者的区别，相对来说，删除消息比撤回消息要简单一些，因为撤回消息不仅要撤回我本地的消息，还要通知其他人，撤回他们记录中的对应消息。而删除消息，则只需要删除我本地记录中的消息。<br/>
当然删除消息也有跟撤回消息不同的地方，就是如果你删除的消息还有上一条，则消息页应该显示上一条消息，如果聊天页就一条消息被你删除了，则聊天页应该删除这个对话。
2. 如果同学们在学习本节课的过程中，特别是最后调试出现的效果跟老师的不一样，那可能是老师对类文件 `/common/js/chatClass.js`做了微调而没有及时更新文档，同学们可以下载本节课的课件，把课件中的类文件替换到你当前类文件代码，在进行调试。
3. 或者你直接赋值下面的类文件代码，贴到你的项目中：
在类文件 `/common/js/chatClass.js`
```js
import {requestUrl} from '@/common/mixins/configData.js';
import {registerGuest} from '@/pages/loginCenter/visitor.js'; //导入具体的方法
import store from '@/store'; // 引入vuex store
class chatClass {
	// 构造函数
	constructor() {
		// ws地址
		this.url = '';
		if (requestUrl.http.startsWith('http')) {
			this.url = 'ws' + requestUrl.http.replace('http', '');
		} else if (requestUrl.http.startsWith('https')) {
			this.url = 'wss' + requestUrl.http.replace('https', '');
		}
		// 是否上线
		this.isOnline = false;
		// socketTask对象
		this.chatSocket = null;
		// 我的信息 vuex 或者从本地获取
		let user = uni.getStorageSync('chatuser') ?
			JSON.parse(uni.getStorageSync('chatuser')) : '';
		this.user = user;
		// 连接websocket
		if (this.user && this.user.token) {
			this.connectSocket();
		}
		// 心跳
		this.heartbeatTimer = null;
		//聊天对象信息
		this.ToObject = false;
		//消息页整个聊天列表数据的未读数
		this.xiaoxiNoreadNum = 0;
	}

	// 连接websocket
	connectSocket() {
		this.chatSocket = uni.connectSocket({
			// http://192.168.2.7:7001
			// ws://192.168.2.7:7001/ws
			// https://lesson07.51yrc.com
			// wss://lesson07.51yrc.com/ws
			url: this.url + `/ws?token=${this.user.token}`,
			complete: () => {},
			timeout: 10000, // 10秒超时
		});

		// 连接成功
		this.chatSocket.onOpen(() => {
			console.log('websocket连接成功');
			// 调用方法
			this.onOpen();
			//启动心跳
			this.heartbeatTimer = setInterval(() => {
				if (this.chatSocket && this.chatSocket.readyState === 1) {
					this.chatSocket.send(JSON.stringify({
						type: 'ping'
					}));
				}
			}, 25000); // 每隔25秒发送一次心跳
		});
		// 接收信息
		this.chatSocket.onMessage(res => {
			// 处理一下不同平台消息格式
			try {
				const data = typeof res.data === 'string' ?
					JSON.parse(res.data) : res.data;
				//调用方法
				this.onMessage(data);

				if (data.type === 'ping') {
					// 响应心跳
					this.chatSocket.send(JSON.stringify({
						type: 'pong'
					}));
				}
			} catch (e) {
				console.error('接收信息错误', e);
			}
		});
		// 断开连接
		this.chatSocket.onClose(res => {
			console.log('断开连接的原因', res);
			clearInterval(this.heartbeatTimer); // 清除心跳
			this.heartbeatTimer = null;
			//调用方法
			this.onClose();

			// 尝试重新连接
			setTimeout(() => {
				console.log('断开连接尝试重新连接websocket');
				//dispatch('initChatuserAction');
				this.connectSocket();
			}, 3000);
		});
		// 错误处理
		this.chatSocket.onError(err => {
			console.error('websocket 错误：', err);
			clearInterval(this.heartbeatTimer); // 清除心跳
			this.heartbeatTimer = null;
			// 尝试重新连接
			setTimeout(() => {
				console.log('错误处理尝试重新连接websocket');
				//dispatch('initChatuserAction');
				this.connectSocket();
			}, 5000);
		});
	}

	// 连接成功
	onOpen() {
		// 用户上线
		this.isOnline = true;
		// 获取离线消息（不在线的时候别人或者群发的消息）
		this.chatGetmessageOffLine();
	}

	// 断开连接
	onClose() {
		// 用户下线
		this.isOnline = false;
		this.chatSocket = null;
	}

	// 接收信息
	onMessage(data) {
		console.log('websocket接收信息', data);
		// 处理接收到的消息
		this.doMessage(data);
	}

	// 关闭链接
	close() {
		// 用户退出登录
		// 调用socketTask 对象 close方法
		this.chatSocket.close();
	}

	// 创建聊天对象信息
	createChatToObject(arg) {
		this.ToObject = arg;
		console.log('聊天对象信息', this.ToObject);
	}

	// 销毁聊天对象信息
	destroyChatToObject() {
		this.ToObject = false;
	}

	// 页面发消息的格式和服务器要一致
	formatSendMessage(args) {
		return {
			id: 0, // 自动生成 UUID,唯一id, 聊天记录id，方便撤回消息
			from_avatar: this.user.avatar, // 发送者头像
			from_name: this.user.nickname || this.user.username, // 发送者名称
			from_id: this.user.id, // 发送者id
			to_id: this.ToObject.id, // 接收者id
			to_name: this.ToObject.name, // 接收者名称
			to_avatar: this.ToObject.avatar, // 接收者头像
			chatType: this.ToObject.chatType, // 聊天类型 单聊
			type: args.type, // 消息类型
			data: args.data, // 消息内容
			options: args.options ? args.options : {}, // 其它参数
			create_time: (new Date()).getTime(), // 创建时间
			isremove: 0, // 0未撤回 1已撤回
			// 发送状态 pending 发送中 success 成功 fail 失败
			sendStatus: args.sendStatus ? args.sendStatus : 'pending',
		}
	}

	// 发送消息（单聊）
	sendmessage(msg) {
		return new Promise((result, reject) => {
			// 把发送的聊天信息存在本地
			let { k } = this.addChatInfo(msg);
			// 消息页的聊天列表更新一下
			this.updateXiaoXiList(msg);
			// 查看我是否在线websocket是否正常连接
			if (!this.meIsOnline()) return reject('我掉线了');
			// 发送消息
			uni.$u.http.post(requestUrl.http + `/api/chat/socket/sendmessage`, {
				sendto_id: this.ToObject.id,
				chatType: this.ToObject.chatType, // 单聊 single 群聊 group
				type: msg.type,
				data: msg.data,
				options: encodeURIComponent(JSON.stringify(msg.options)), // 选填
			}, {
				header: {
					token: uni.getStorageSync('chatuser_token'),
				}
			}).then(res => {
				console.log('发送消息到服务器结果res', res);
				msg.id = res.data.data.id;
				msg.sendStatus = 'success';
				console.log('发送消息成功之后的msg', msg);
				// 更新本地的历史记录 send不用传因为已经发送完成了
				this.updateChatInfo(msg, k);
				// 成功返回给页面
				result(res);
			}).catch(err => {
				//console.log('发送消息到服务器失败', err);
				msg.sendStatus = 'fail';
				// 更新本地的历史记录 send不用传因为已经发送完成了
				this.updateChatInfo(msg, k);
				// 失败返回给页面
				reject(err);
			});
		});
	}
	
	// 把聊天信息存在本地
	addChatInfo(msg, isSend = true) {
		// 存本地key值设计 chatDetail_我的id_单聊群聊_和谁聊接收人(个人还是群)id
		// key:`chatDetail_${this.user.id}_${msg.chatType}_${xx}`
		// 重点分析接收人id
		// 如果是单聊则是用户id,如果是群聊，则是群id(群聊id放在消息to_id中)
		let id = msg.chatType == 'single' ? (isSend ? msg.to_id : msg.from_id) : msg.to_id;
		let key = `chatDetail_${this.user.id}_${msg.chatType}_${id}`;
		// 先获取历史记录
		let list = this.getChatInfo(key);
		console.log('获取历史记录', list);
		// 做个标识，方便之后拿具体某条历史消息
		msg.k = 'k' + list.length;
		// 将消息放入历史记录
		list.push(msg);
		// 重新存历史记录到本地（因为加了新消息）
		uni.setStorageSync(key, JSON.stringify(list));
		// 返回
		return {
			data: msg,
			k: msg.k,
		}
	}
	
	
	// 获取本地历史记录, 传key值则找指定聊天记录
	getChatInfo(key = false) {
		if (!key) {
			// 没有传key 则找当前会话聊天记录
			key = `chatDetail_${this.user.id}_${this.ToObject.chatType}_${this.ToObject.id}`;
		}
		console.log('获取历史记录, 传key值则找指定聊天记录的key，当前key值',key);
		let list = uni.getStorageSync(key);
		// console.log('获取历史记录得到的数据', list);
		if (list) {
			if (typeof list == 'string') {
				list = JSON.parse(list);
			}
		} else {
			list = [];
		}
		return list;
	}
	
	// 更新指定的本地历史记录信息(不急着更新可以异步)
	async updateChatInfo(msg, k, isSend = true) {
		// 获取原来的历史记录
		// 存本地key值设计 chatDetail_我的id_单聊群聊_和谁聊接收人(个人还是群)id
		// key:`chatDetail_${this.user.id}_${msg.chatType}_${xx}`
		// 重点分析接收人id 
		// isSend = true 代表我是发送人from_id
		// 接收人就是to_id
		// 如果是单聊则是用户id,如果是群聊，则是群id(群聊id放在消息to_id中)
		let id = msg.chatType == 'single' ? (isSend ? msg.to_id : msg.from_id) : msg.to_id; //接收人|群id 
		let key = `chatDetail_${this.user.id}_${msg.chatType}_${id}`;
		console.log('更新指定的历史记录信息key', key);
		// 先获取历史记录
		let list = this.getChatInfo(key);
		console.log('先获取历史记录', list);
		// 根据标识k去查找要更新的历史记录
		let index = list.findIndex(e => e.k == k);
		// 没找到
		if (index == -1) return;
		// 找到了，修改指定消息
		list[index] = msg;
		// 改完之后，整个重新存一下
		console.log('改完之后，整个重新存一下', key, list);
		uni.setStorageSync(key, list);
	}
	
	// 删除消息页指定的本地历史记录信息
	deleteChatInfo(to_id, chatType){
		return new Promise((resolve,reject) => {
			try{
				let xiaoxiList = this.getXiaoXiList();
				// 找到当前聊天
				let index = xiaoxiList.findIndex(v => v.id == to_id && v.chatType == chatType);
				if(index != -1){
					// 找到了
					// 删除这个历史记录
					xiaoxiList.splice(index, 1);
					// 处理完了之后，存储消息页列表本地历史信息
					this.setXiaoXiList(xiaoxiList);
					// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
					this.updateXiaoXiListNoreadNum();
					// 消息页，整个消息列表的数据也存入了vuex中
					// 更新一下vuex中的消息列表的数据
					uni.$emit('updateXiaoXiList', xiaoxiList);
					// 执行后续操作
					return resolve();
				}
			}catch{
				return reject();
			}
		});
	}
	
	
	// 删除或者(撤回)（与某个群所有或者某条聊天信息，与某个人的所有或者某条聊天信息）
	clearChatInfo(to_id, chatType, msgid = false, doaction = 'revoke'){
		let key = `chatDetail_${this.user.id}_${chatType}_${to_id}`;
		// 根据key获取信息
		let chatDetail = uni.getStorageSync(key);
		chatDetail = chatDetail && typeof chatDetail == 'string' ? 
		             JSON.parse(chatDetail) : chatDetail;
		console.log('本地根据key获取的聊天详细信息', chatDetail);
		if(msgid){
			// 删除与某人或者某群对话中的某一条聊天记录
			if(chatDetail){
				// 拿到具体的某条聊天信息
				let k = chatDetail.findIndex(v=> v.id === msgid);
				if(k > -1){
					console.log('删除或者(撤回)与某人或者某群对话中的某一条聊天记录', chatDetail[k]);
					if(doaction && doaction == 'delete'){
						// 删除这条记录
						chatDetail.splice(k, 1);
					}else{
						// 撤回操作
						// 将这条记录的属性isremove改成1或者true 就会自动隐藏
						chatDetail[k].isremove = 1; 
					}
					// 重新存储
					uni.setStorageSync(key, chatDetail);
				}
			}
		}else{
			// 删除与某人或者某群对话中的本地所有记录
			uni.removeStorageSync(key);
			console.log('删除与某人或者某群对话中的本地所有记录');
		}
		// 消息页数据重新处理
		return new Promise((resolve,reject) => {
			let xiaoxiList = this.getXiaoXiList();
			// 找到当前聊天
			let index = xiaoxiList.findIndex(v => v.id == to_id && v.chatType == chatType);
			if(index != -1){
				// 找到了
				if(msgid){
					if(chatDetail){
						// 执行后续操作 - 如：更新消息页
						return resolve(index);
					}else{
						return reject();
					}
				}else{
					// 消息页删除这个记录
					xiaoxiList.splice(index, 1);
					// 处理完了之后，存储消息页列表本地历史信息
					this.setXiaoXiList(xiaoxiList);
					// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
					this.updateXiaoXiListNoreadNum();
					// 消息页，整个消息列表的数据也存入了vuex中
					// 更新一下vuex中的消息列表的数据
					uni.$emit('updateXiaoXiList', xiaoxiList);
					// 执行后续操作
					return resolve();
				}
			}
			return reject();
		});
	}
	
	
	// 修改某个对话信息（单聊和群聊, 处理设置功能）
	// [如：置顶、免打扰、是否展示昵称、是否提醒、是否确认进群等]
	updateSomeOneChatItem(someone, updatedata){
		return new Promise((resolve,reject) => {
			let xiaoxiList = this.getXiaoXiList();
			// 找到当前聊天
			let index = xiaoxiList.findIndex(v => v.id == someone.id && 
			v.chatType == someone.chatType);
			if(index != -1){
				// 找到了
				console.log('传递过来的要更新的数据',updatedata);
				// 更新数据
				xiaoxiList[index] = {
					...xiaoxiList[index],
					// 重新赋值
					istop: updatedata.istop, //置顶
					nowarn: updatedata.nowarn, //免打扰
					stongwarn: updatedata.stongwarn, //是否提醒 
					shownickname: updatedata.shownickname, //是否显示群成员昵称
				};
				// 处理完了之后，存储消息页列表本地历史信息
				this.setXiaoXiList(xiaoxiList);
				// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
				// this.updateXiaoXiListNoreadNum();
				// 消息页，整个消息列表的数据也存入了vuex中
				// 更新一下vuex中的消息列表的数据
				uni.$emit('updateXiaoXiList', xiaoxiList);
				// 执行后续操作
				return resolve(xiaoxiList[index]);
			}
			return reject();
		});
	}
	
	
	// 消息页将某条消息更新成你指定的消息
	XiaoXiListUpdataZhiDingMsg(XiaoXiListId,chatType,msg){
		console.log('---消息页将某条消息更新成你指定的消息id---',XiaoXiListId);
		console.log('---消息页将某条消息更新成你指定的消息内容---',msg);
		// 获取消息页列表本地历史信息（消息页消息列表）
		let list = this.getXiaoXiList();
		console.log('获取消息页列表旧历史', list);
		// 查消息页列表索引
		let index = list.findIndex(v => v.chatType == chatType && v.id == XiaoXiListId);
		if(index != -1){
			// 主要是更新data部分
			let data = msg.data;
			try {
				if(typeof msg.data == 'string'){
					data = JSON.parse(msg.data);
				}
			}catch {
				data = msg.data;
			}
			// 当发送消息是图片视频等，消息页列表最新聊天的最后一条消息显示[图片][视频]等
			let isSend = msg.from_id === this.user.id ? true : false;
			let datadesc = this.XiaoXiListAnyOneLastMsgFormat(data, msg, isSend);
			// 找到了消息列表的数据，将这个数据换成指定的数据
			let findItem = list[index];
			// 更新以下内容：时间 内容 类型等等
			findItem.update_time = msg.create_time;
			findItem.data = data;
			findItem.datadesc = datadesc;
			findItem.type = msg.type;
			// findItem.avatar = avatar; // 消息页的头像不用更新，因为是跟当前聊天对象的记录
			// findItem.name = name; // 消息页的name不用更新，因为是跟当前聊天对象的记录
			findItem.isremove = msg.isremove;
			
			
			// 处理完了之后，存储消息页列表本地历史信息
			this.setXiaoXiList(list);
			// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
			this.updateXiaoXiListNoreadNum();
			// 消息页，整个消息列表的数据也存入了vuex中
			// 更新一下vuex中的消息列表的数据
			uni.$emit('updateXiaoXiList', list);
		}
	}
	
	// 消息页的聊天列表更新一下
	updateXiaoXiList(msg, isSend = true) {
		console.log('消息页最新的一条消息',msg);
		// 获取消息页列表本地历史信息（消息页消息列表）
		let list = this.getXiaoXiList();
		console.log('获取消息页列表旧历史', list);
		// 判断是不是正在和对方聊天，正在聊天页
		// 如果正在聊天页，就没有必要更新消息页的列表了
		let isCurrentChat = false; // 默认不在聊天页
		// 消息页每条数据需要配合服务器的数据，（消息页消息列表）大概有这些字段
		/*
		{
			// 单聊
			id: `用户|群id`,
			avatar: `用户|群头像`,
			name: `用户|群昵称`,
			chatType:'单聊|群聊',
			update_time: '最新的时间',
			data: '最新一条消息',
			type:'最新一条消息类型',
			noreadnum:'未读数',
			istop:'置顶情况',
			shownickname:'是否展示昵称',
			nowarn:'消息免打扰',
			stongwarn: '消息提醒'
			
			// 群聊还有以下字段
			user_id: '群管理员id',
			remark:'群公告',
			invite_confirm:'确认进群'
			...
		}
		*/
		// 重点处理上面的这几个字段
		let id = 0; //接收人|群 id
		let avatar = ''; //接收人|群 头像
		let name = ''; // 接收人|群 称呼
		// 先判断是单聊还是群聊
		if (msg.chatType == 'single') {
			//单聊 
			//先看聊天对象是否存在
			/*
			if(this.ToObject){
				// 存在聊天对象则在聊天页根据isSend判断
				// isSend为true 则我是发送者
				// 则这条消息msg.to_id 就是接收人的id 与聊天人 this.ToObject.id
				// 如果二者相等，则说明正在跟当前接收人聊天
				// 那么消息页就不用更新当前聊天人的信息比如提示发了几条消息等
				isCurrentChat = isSend ? this.ToObject.id === msg.to_id :
				// 否则我不是发送者刚好反过来
				this.ToObject.id === msg.from_id;
			}else{
				// 不存在聊天对象肯定就不在聊天页
				isCurrentChat = false;
			} */
			isCurrentChat = this.ToObject ? isSend ? this.ToObject.id === msg.to_id :
				this.ToObject.id === msg.from_id : false;
			// 处理 接收人|群 id avatar name
			id = isSend ? msg.to_id : msg.from_id;
			avatar = isSend ? msg.to_avatar : msg.from_avatar;
			name = isSend ? msg.to_name : msg.from_name;
	
		} else if (msg.chatType == 'group') {
			//群聊
			//先看聊天对象是否存在
			isCurrentChat = this.ToObject && this.ToObject.id === msg.to_id;
			// 处理 接收人|群 id avatar name
			id = msg.to_id ;
			avatar = msg.to_avatar ;
			name = msg.to_name ;
		}
	
		// 接下来看消息页消息列表是否存在跟当前聊天人的对话
		let index = list.findIndex(v => {
			// 查消息类型和接收人聊天人id
			return v.chatType == msg.chatType && v.id == id;
		});
		// 最后把消息页最新聊天的最后一条消息展示处理一下
		// let data = typeof msg.data == 'string' ? JSON.parse(msg.data) : msg.data;
		let data = msg.data;
		try {
			if(typeof msg.data == 'string'){
				data = JSON.parse(msg.data);
			}
		}catch {
			data = msg.data;
		}
		// 当发送消息是图片视频等，消息页列表最新聊天的最后一条消息显示[图片][视频]等
		let datadesc = this.XiaoXiListAnyOneLastMsgFormat(data, msg, isSend);
		
		// 字段noreadnum 未读消息数量判断
		// isSend为true说明现在处于聊天页
		// 处于聊天页或者聊天当中,那么消息页，聊天列表就没必要+1
		let noreadnum = (isSend || isCurrentChat) ? 0 : 1;
		// 看能不能查到跟当前聊天人的对话
		if (index == -1) {
			// 如果查不到，则新建一个跟当前聊天人的对话信息放到消息页列表最上面
			// 新建对话信息
			// 单聊
			let chatItem = {
				id: id,
				avatar: avatar,
				name: name,
				chatType: msg.chatType,
				update_time: (new Date()).getTime(),
				data: data,
				datadesc: datadesc,
				type: msg.type,
				noreadnum: noreadnum,
				istop: false, //是否置顶
				shownickname: 0, //是否显示昵称
				nowarn: 0, //消息免打扰
				stongwarn: 0, //是否提示来消息了
				isremove: msg.isremove, // 是否撤回
				redirect: msg.redirect ? msg.redirect : false, // 跳转字段
			};
			// 群聊
			if (msg.chatType == 'group') {
				console.log('群聊此时的消息处理', msg);
				chatItem = {
					...chatItem,
					user_id: msg.group && msg.group.user_id ? msg.group.user_id : 0, //群主
					remark: msg.group && msg.group.remark ? msg.group.remark : '', // 群公告
					// 是否需要管理员确认才能进群 默认不需要0
					invite_confirm: msg.group && msg.group.invite_confirm ? msg.group.invite_confirm : 0, 
					// 是否显示群成员昵称
					shownickname: true, //群聊默认显示
				}
			}
			// 放在最上面
			list = [chatItem, ...list];
		} else {
			// 查到了，则更新消息页，消息列表中的这条对话信息让它是最新的
			let findItem = list[index];
			// 则更新以下内容：时间 内容 类型等等
			findItem.update_time = (new Date()).getTime();
			findItem.data = data;
			findItem.datadesc = datadesc;
			findItem.type = msg.type;
			findItem.avatar = avatar;
			findItem.name = name;
			findItem.isremove = msg.isremove;
			findItem.redirect = msg.redirect ? msg.redirect : false;
			// 未读数更新
			findItem.noreadnum += noreadnum;
			console.log('查到了，则更新消息页最新一条消息', findItem);
			// 把这条消息放在消息页，消息列表最上面
			list = this.arrToFirst(list, index);
		}
	
		// 重新存一下 存储消息页列表本地历史信息
		this.setXiaoXiList(list);
	
		// 更新(获取)消息页，整个消息列表的未读数
		this.updateXiaoXiListNoreadNum(list);
	
		// 消息页，整个消息列表的数据也存入了vuex中
		// 更新一下vuex中的消息列表的数据
		uni.$emit('updateXiaoXiList', list);
		// 最后返回
		console.log('获取或更新消息页列表为最新数据', list);
		return list;
	
	}
	
	// 当发送消息是图片视频等，消息页列表最新聊天的最后一条消息显示[图片][视频]等
	XiaoXiListAnyOneLastMsgFormat(data, msg, isSend){
		console.log('消息页显示[图片][视频]等的data处理数据',data);
		// 显示到消息列表的新属性
		let datadesc = ``;
		let dataType = data.dataType ? data.dataType : msg.dataType;
		switch(dataType){
			case 'image':
			    if(data && data.otherData && data.otherData.type){
				    if(data.otherData.type == 'iconMenus'){
					    datadesc = `[表情]`;
						if(data.otherData.typedata && data.otherData.typedata.name){
							datadesc += `[${data.otherData.typedata.name}]`;
						}
				    }else if(data.otherData.type == 'image'){
						datadesc = `[图片]`;
					}
			    }else{
					if(msg && msg.otherData && msg.otherData.type){
						if(msg.otherData.type == 'iconMenus'){
						    datadesc = `[表情]`;
							if(msg.otherData.typedata && msg.otherData.typedata.name){
								datadesc += `[${msg.otherData.typedata.name}]`;
							}
						}else if(msg.otherData.type == 'image'){
							datadesc = `[图片]`;
						}
					}
				}
			    break;
			case 'audio':
			    datadesc = `[语音]`;
			    break;
			case 'video':
			    datadesc = `[视频]`;
			    break;
			case 'file':
			    datadesc = `[文件]`;
			    break;
			case 'pdf':
			    datadesc = `[pdf文件]`;
			    break;
			case 'docx':
			    datadesc = `[word文档]`;
			    break;
		}
		// 是否显示发送者
		datadesc = isSend ? datadesc : `${msg.from_name}: ${datadesc}`;
		console.log('消息页显示[图片][视频]等的显示数据',datadesc);
		return datadesc;
	}
	
	// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
	async updateXiaoXiListNoreadNum(list = false) {
		// 获取消息页列表本地历史信息
		list = !list ? this.getXiaoXiList() : list;
		// 循环list里面的每一项把属性noreadnum相加一起
		let num = 0;
		list.forEach(v => {
			num += v.noreadnum;
		});
		// 可在这里执行更新，或者赋值给实例属性在页面调用
		// 实例属性:消息页整个聊天列表数据的未读数
		this.xiaoxiNoreadNum = num;
		console.log('消息页整个聊天列表数据的未读数：', num);
		// 消息总未读数变化触发
		uni.$emit('totalNoReadNum', num);
		// 还可以返回
		return num;
	}
	
	// 数组元素置顶
	arrToFirst(arr, index) {
		// 判断：因为等于0本来就在最上面
		if (index != 0) {
			arr.unshift(arr.splice(index, 1)[0]);
		}
		return arr;
	}
	
	// 获取消息页列表本地历史信息
	getXiaoXiList() {
		// 定义消息列表key,支持多用户切换
		let key = 'chatlist_' + this.user.id;
		let list = uni.getStorageSync(key);
		return list ? JSON.parse(list) : [];
	}

	// 存储消息页列表本地历史信息
	setXiaoXiList(list) {
		// 定义消息列表key,支持多用户切换
		let key = 'chatlist_' + this.user.id;
		uni.setStorageSync(key, JSON.stringify(list));
	}

	// 查看我是否在线websocket是否正常连接
	meIsOnline() {
		if (!this.isOnline) {
			// 我不在线可以提示我确认重新连接websocket
			this.connectWebsocketcomfirm();
			return false;
		}
		return true;
	}

	// 提示我确认重新连接websocket
	connectWebsocketcomfirm(msdata = null, confirmCallback = false, cancelCallback = false) {
		uni.showModal({
			title: msdata && msdata.title ? msdata.title :  '系统提示',
			content: msdata && msdata.content ? msdata.content : '由于服务器或者网络原因，您已经掉线了，是否重新连接',
			showCancel: true,
			cancelText: msdata && msdata.cancelText ? msdata.cancelText : '取消',
			confirmText: msdata && msdata.confirmText ? msdata.confirmText : '重新连接',
			success: res => {
				if (res.confirm) {
					if(confirmCallback && typeof confirmCallback == 'function'){
						confirmCallback();
					}else{
						this.connectSocket();
					}
				}else{
					console.log('点了取消');
					if(cancelCallback && typeof cancelCallback == 'function'){
						cancelCallback();
					}
				}
			},
		});
	}
	
	// 处理接收到的消息
	async doMessage(msg){
		console.log('处理接收到的消息',msg);
		if(msg.type == 'system'){
			console.log('系统消息单独处理');
		}else if(msg.type == 'singleChat'){
			let msgData = msg.data;
			if(msgData.actionType && msgData.actionType =='revoke'){
				// 撤回操作
				// 获取历史记录, 传key值则找指定聊天记录
				// 不传key则构建一个聊天对象因为对方可能不在聊天页
				// this.ToObject.chatType = msgData.chatType;
				// this.ToObject.id = msgData.chatType == 'single' ? msgData.from_id : msgData.to_id; //接收人|群id 
				let keyId = msgData.chatType == 'single' ? msgData.from_id : msgData.to_id; //接收人|群id
				// 因为this.ToObject初始化默认false,无法赋值，所以我们直接传key
				let key = `chatDetail_${this.user.id}_${msgData.chatType}_${keyId}`;
				let chatInfoList = this.getChatInfo(key);
				console.log('----撤回处理获取所有历史记录----',chatInfoList);
				// 根据id找到要撤回的消息
				let index = chatInfoList.findIndex(v => v.id == msgData.id);
				if(index != -1){
					// 找到了
					let revokeMsg = chatInfoList[index];
					console.log('----找到了要撤回的消息历史记录----', revokeMsg);
					revokeMsg.isremove = 1;
					// 找到k属性
					let k = revokeMsg.k;
					// 更新指定的历史记录信息(不急着更新可以异步)
					await this.updateChatInfo(revokeMsg, k, false);
					// 消息页列表要不要更新：取决于撤回的消息是不是最新的消息
					if(chatInfoList.length - 1 == index){
						// 是最新的消息
						// 消息页修改data 和 type
						revokeMsg.data = msgData.data;
						revokeMsg.type = msgData.type;
						revokeMsg.update_time = (new Date()).getTime();
						// 消息页的聊天列表更新一下
						this.updateXiaoXiList(revokeMsg, false);
						// 全局通知数据--聊天页做更新
					}else{
						// 不是最新消息
						// 全局通知数据--聊天页做更新
					}
					// 全局通知数据--聊天页做更新
					uni.$emit('onMessage', {
						actionType: msgData.actionType,
						...revokeMsg,
					});
				}
			}else{
				// 把聊天信息存在本地
				let { data } = this.addChatInfo(msgData, false);
				// 消息页的聊天列表更新一下
				this.updateXiaoXiList(data, false);
				// 全局通知数据
				uni.$emit('onMessage', data);
				
			}
		}
	}
		
	// 进入聊天页，将消息页当前聊天用户的未读数清零
	async goChatPageUpdateXiaoXiNoReadNum(to_id, chatType){
		let xiaoxiList = this.getXiaoXiList();
		// 找到当前聊天
		let index = xiaoxiList.findIndex(v => v.id == to_id && v.chatType == chatType);
		if(index != -1){
			// 找到了
			xiaoxiList[index].noreadnum = 0;
			// 修改完了之后，存储消息页列表本地历史信息
			this.setXiaoXiList(xiaoxiList);
			// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
			this.updateXiaoXiListNoreadNum();
			// 消息页，整个消息列表的数据也存入了vuex中
			// 更新一下vuex中的消息列表的数据
			uni.$emit('updateXiaoXiList', xiaoxiList);
			
		}
	}

    // 聊天页设置相关信息获取
    getChatPageSet(to_id, chatType){
        let xiaoxiList = this.getXiaoXiList();
        // 找到当前聊天
        let index = xiaoxiList.findIndex(v => v.id == to_id && v.chatType == chatType);
        if(index != -1){
            // 找到了
            return xiaoxiList[index];
        }
        return null;
    }
	
	// 获取离线消息（不在线的时候别人或者群发的消息）
	chatGetmessageOffLine(){
		uni.$u.http.post(requestUrl.http + `/api/chat/chatGetmessageOffLine`, {}, {
			header: {
				token: this.user.token,
			},
		}).then(res => {
			console.log('服务器返回离线消息', res);
		}).catch(err => {
			console.log('服务器返回离线消息失败', err);
			if(err.data && err.data.data == 'Token 令牌不合法！'){
				if(this.user.role == 'visitor'){
					console.log('游客如果token令牌错误，重新获取token并连接websocket');
					this.registerGuestAndConnect();
				}else if(this.user.role == 'user'){
					console.log('登录用户token不正确，说明在的别的设备登录了，则清空本地登录信息，在换成游客模式');
					store.dispatch('logoutAction', ()=>{
						this.doRegisterGuest();
					});
				}
			}
		});
	}
	
	// 游客如果token令牌错误，重新获取token并连接websocket
	async registerGuestAndConnect(){
		try{
			this.connectWebsocketcomfirm({
				title:'来自系统的提示',
				content:'您之前在其它的设备打开过现在已掉线，是否在本设备重新连接',
			}, ()=>{
				this.doRegisterGuest();
			});
		}catch(error){
			console.error('游客获取token失败',error);
		}
	}
	
	// 游客如果token令牌错误，重新获取token并连接websocket
	async doRegisterGuest(){
		const userData = await registerGuest(store);
		console.log('游客重新获取token等信息', userData);
		
		if(userData && userData.token){
			// 更新用户信息
			this.user = userData;
			// 连接websocket
			this.connectSocket();
		}
	}
	
	// 撤回消息
	revokeChatInfo(options){
		return new Promise((resolve,reject)=>{
			uni.$u.http.post(requestUrl.http + `/api/chat/revokeMessage`,options,{
				header:{
					token: this.user.token, 
				}
			}).then(res=>{
				console.log('服务器撤回消息结果',res);
				// 删除或者(撤回)（与某个群所有或者某条聊天信息，与某个人的所有或者某条聊天信息）
				this.clearChatInfo(options.to_id, options.chatType, options.id).then(()=>{
					resolve(res.data.data);
				});
			}).catch(err=>{
				console.log('服务器撤回消息失败结果',err);
				uni.showToast({title: err.data.data, icon:'none'});
				reject(err);
			});
		});
	}
	
}

export default chatClass;
```





### 1. 删除聊天页某条本地消息(并返回消息页对应聊天对象索引)方法
在类文件 `/common/js/chatClass.js`
```js
    // 删除或者(撤回)（与某个群所有或者某条聊天信息，与某个人的所有或者某条聊天信息）
	clearChatInfo(to_id, chatType, msgid = false, doaction = 'revoke'){
		let key = `chatDetail_${this.user.id}_${chatType}_${to_id}`;
		// 根据key获取信息
		let chatDetail = uni.getStorageSync(key);
		chatDetail = chatDetail && typeof chatDetail == 'string' ? 
		             JSON.parse(chatDetail) : chatDetail;
		console.log('本地根据key获取的聊天详细信息', chatDetail);
		if(msgid){
			// 删除与某人或者某群对话中的某一条聊天记录
			if(chatDetail){
				// 拿到具体的某条聊天信息
				let k = chatDetail.findIndex(v=> v.id === msgid);
				if(k > -1){
					console.log('删除或者(撤回)与某人或者某群对话中的某一条聊天记录', chatDetail[k]);
					if(doaction && doaction == 'delete'){
						// 删除这条记录
						chatDetail.splice(k, 1);
					}else{
						// 撤回操作
						// 将这条记录的属性isremove改成1或者true 就会自动隐藏
						chatDetail[k].isremove = 1; 
					}
					// 重新存储
					uni.setStorageSync(key, chatDetail);
				}
			}
		}else{
			// 删除与某人或者某群对话中的本地所有记录
			uni.removeStorageSync(key);
			console.log('删除与某人或者某群对话中的本地所有记录');
		}
		// 消息页数据重新处理
		return new Promise((resolve,reject) => {
			let xiaoxiList = this.getXiaoXiList();
			// 找到当前聊天
			let index = xiaoxiList.findIndex(v => v.id == to_id && v.chatType == chatType);
			if(index != -1){
				// 找到了
				if(msgid){
					if(chatDetail){
						// 执行后续操作 - 如：更新消息页
						return resolve(index);
					}else{
						return reject();
					}
				}else{
					// 消息页删除这个记录
					xiaoxiList.splice(index, 1);
					// 处理完了之后，存储消息页列表本地历史信息
					this.setXiaoXiList(xiaoxiList);
					// 更新(获取)消息页，整个消息列表的未读数（不急可以异步执行）
					this.updateXiaoXiListNoreadNum();
					// 消息页，整个消息列表的数据也存入了vuex中
					// 更新一下vuex中的消息列表的数据
					uni.$emit('updateXiaoXiList', xiaoxiList);
					// 执行后续操作
					return resolve();
				}
			}
			return reject();
		});
	}
	
```


### 2. 删除聊天页本地某条聊天消息
在组件 `/components/chat-item/chat-item.vue`
```js
data(){
	return {
		...
		menuList: [{
				name: "删除",
				type: 'deleteChatItem'
			},
			...
		],
		...
	}
},
...
clickType(e) {
	console.log('点击菜单',e);
	switch (e){
		case 'deleteChatItem':
			// 删除自己的某条聊天记录（本地）
			// 重点处理to_id
			let to_id = this.item.chatType == 'single' ?  
			this.me.id == this.item.to_id ? 
			this.item.from_id : this.item.to_id : this.item.to_id;
			// 删除本地记录
			this.chatClass.clearChatInfo(to_id, this.item.chatType, 
			this.item.id, 'delete').then((xiaoxiListIndex)=>{
				// 通知聊天页删除这条记录
				uni.$emit('deleteChatItem',{
					item: this.item,
					xiaoxiListId: to_id, // 消息页对话的id
				});
			});
			break;
		case 'removeChatItem':
			...
			break;
	}
	...
},
...
```


### 3. 删除聊天页页面某条聊天消息
在页面 `/pages/chat/chat.nvue`
```js
...
onLoad(e) {
	...
	try{
		...
		// 监听处理接收到的消息
		uni.$on('onMessage', v => {
			...
		});
		// 监听删除了某条聊天记录
		uni.$on('deleteChatItem', v => {
			console.log('---传过来的v---',v);
			console.log('---当前的聊天数据---',this.chatDataList);
			console.log('---v.xiaoxiListId---', v.xiaoxiListId); 
			// 聊天页最后一条消息索引
			let lastIndex = this.chatDataList.length - 1;
			// 要删除的消息索引
			let deleteIndex = this.chatDataList.findIndex(e => e.id === v.item.id);
			if(deleteIndex != -1){
				// 删除聊天页的指定聊天记录
				this.chatDataList.splice(deleteIndex, 1);
			}
			// 如果删除的消息就是最后一条消息，则还要更新一下消息页的显示
			if(deleteIndex == lastIndex){
				// 如果有上一条消息，消息页显示上一条消息
				if(deleteIndex > 0){
					let prevIndex = lastIndex - 1;
					let msg = this.chatDataList[prevIndex];
					console.log('删除时候有上一条记录', msg);
					// 消息页将某条消息更新成你指定的消息
					this.chatClass.XiaoXiListUpdataZhiDingMsg(v.xiaoxiListId, v.item.chatType, msg);
					
				}else{
					// 没有上一条消息，就一条消息被你删了
					// 删除消息页指定的历史记录信息
					this.chatClass.deleteChatInfo(v.xiaoxiListId, v.item.chatType);
				}
			}
		});
		
	}catch{
		...
	}

},
...
```


### 4. 调整消息页data的数据显示
在页面 `/pages/xiaoxi/xiaoxi.nvue`
```js
methods: {
	// 获取消息列表
	getDataList(){
		console.log('消息列表', this.xiaoxiList);
		this.chatList = this.xiaoxiList.map(v => {
			return {
				...v,
				avatar: v.avatar.startsWith('http') ? v.avatar : requestUrl.http + v.avatar,
				nickname: v.name,
				chat_time: parseTimeJs.gettime(v.update_time),
				data: v.data && v.data.data ? v.data.data : v.data, // 调整data显示
				datacount: v.noreadnum,
				isZhiding: v.istop,
			}
		});
		console.log('消息列表最终显示到页面的数据', this.chatList);
	},
	...
}
```

### 5. 消息页页面显示
在组件 `/components/chat-chatlist/chat-chatlist.vue`
```js
computed:{
	...
	// 昵称下面的小字
	showText(){
		if(this.item.isremove){
			return this.item.datadesc + `撤回了一条消息`;
		}
		if(this.item.type == 'text'){
			// 纯文字 和 头像文字
			if(typeof this.item.data == 'string' ||
				typeof this.item.data == 'number'){
				return this.item.datadesc + this.item.data;
			}else if(typeof this.item.data == 'object'){
				return this.item.datadesc + this.item.data.data;
			}
		}else if(this.item.type == 'systemNotice'){
			...
		}
		else{
			...
		}
	},
}
```



## 三、好友申请实时显示
### 1. 好友申请列表修复头像显示错误
在页面 `/pages/applyMyfriend/applyMyfriend.vue`
```js
...
filters:{
	//头像
	avatarShow(item){
		if(item &&  item.user &&  item.user.avatar){
			let avatar = item &&  item.user.avatar;
			avatar = avatar && avatar.startsWith('http') ? avatar : `${requestUrl.http}${avatar}`;
			return avatar;
		}
		return ``;
	},
	...
}
...
```





























































































































































