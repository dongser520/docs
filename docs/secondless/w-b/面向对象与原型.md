---
navbar: true
sidebar: auto
title: 章节2.面向对象与原型 
---

前言
> 1. 关于基础 <br/>
> 本章节开始讲js中的面向对象与原型，需要有一定的基础，对于零基础学员，只需要按照我们的课程学习顺序学下来即可，对于有一定基础直接开始学习本季度课程的同学，如果在学习的过程感觉很吃力，说明你的js基础还不牢靠，那么建议你回去学习一下我们第二学期第1季的课程。 <br/> <br/>
> 2. 关于课件和资料  <br/>
> 大家直接去查看我们视频的第三课，里面告诉大家学习资料下载和学习文档地址，之后我们在课程中就不再提及了。<br/> <br/>
> 3. 课前准备  <br/>
> 本期课程会学习到ajax相关技术，需要用到搭建本地服务器<br/><br/>
> ① 如果你是从第二学期第1季学习过来的同学，无需课前准备，因为我们继续沿用上一季的代码及搭建的本地服务器。<br/><br/>
> ② 如果你是有一定基础直接学习本季课程的同学，首先需要去群文件里面下载本节课的课件【第二学期第2季课前代码】（也就是我们第1季的代码），然后需要搭建本地服务器（我们在上一季课程讲了两种搭建本地服务器的方法，为了便于统一学习，因为有的同学使用的是window系统，有的同学使用的是苹果电脑，我们统一使用的是UPUPWANK软件搭建的本地服务器）<br/><br/>
> 具体步骤查看第二学期第1季视频： <a href="javascipt(void:0);" target="_blank" title="搭建本地服务器点击查看">搭建本地服务器</a> <br/>
> 开发工具使用的是vscode，具体安装： <a href="https://study.163.com/course/courseLearn.htm?courseId=1213374826&share=2&shareId=480000002289674#/learn/video?lessonId=1285001250&courseId=1213374826" target="_blank" title="安装vscode(第一学期视频第1课)点击查看">安装vscode(第一学期视频第1课)</a>


## Ⅰ、创建对象
### ① 创建对象，剖析问题
> ```javascript
> let girl = new Object(); //new 方式
> //let girl = Object(); // new 关键字可以省略
> girl.height = '170cm'; // 分号，创建属性字段，等于号右边是值
> girl.weight = '52kg';
> girl.age = 25;         //数值
> girl.looks = 'very beautiful';
> girl.bust = '90cm';
> girl.waist = '60cm';
> girl.hip = '90cm';
> girl.education = '研究生以上学历';
> girl.family = '富二代';
> //对象中的函数（方法）
> girl.Cando = function(){
>     return '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
> }
> console.log(girl);
> console.log(girl.looks);//属性
> console.log(girl.Cando());//方法
> 
> //此时改动一下方法
> girl.Cando = function(){
>   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   //this表示当前作用域下的对象，this代表的就是girl对象
>   //this表示new Object()实例化出来的那个对象
>   //this要放在一个作用域下，比如 girl.Cando = function(){}
>   //function(){} 就是box作用域下的方法，方可用this，来表示girl本身
> }
> console.log(girl.Cando());//方法
> 
> 
> 
> //console.log(this);//window
> // var height = '180cm';
> // console.log(this.height);
> 
> //现在问题是，如果我想创建一个类似的对象，怎么写？
> 
> // let girl2 = new Object(); //new 方式
> //let girl2 = Object(); // new 关键字可以省略
> let girl2 = girl;
> girl2.height = '180cm'; // 分号，创建属性字段，等于号右边是值
> girl2.weight = '52kg';
> girl2.age = 25;         //数值
> girl2.looks = 'very beautiful';
> girl2.bust = '100cm';
> girl2.waist = '60cm';
> girl2.hip = '90cm';
> girl2.education = '硕士以上学历';
> girl2.family = '富二代有企业';
> //对象中的函数（方法）
> girl2.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心，天天哄我！';
> }
> 
> console.log(girl2.Cando());//方法
> 
> //发现代码写了一大段，两个对象大部分属性和方法都是相同的？
> //另外发现 let girl2 = girl;
> 
> console.log(girl.Cando());
> console.log(girl2.Cando());
> //两个结果一样了，girl对象的方法改变了，原因大家知道，girl2的方法替换了girl对象的方法，因为它们指向的都是同一个对象，基础章节讲过了
> //两种方式都不行，代码都会有重复，那么有没有什么办法来避免重复这么多代码呢，答案是有的，我们下节课讲
> ```

### ② 传统面向对象：工厂模式
> 我们上一节课通过案例说明了，不管你是通过new Object()创建一个类似对象，还是将第一个对象赋值给第二个变量，都无法解决代码重复冗余问题。聪明的同学，可能会马上想到一种办法，就是写一个函数，因为函数可以传参，并且函数可以被多次调用，我们来写一下，看能不能解决。<br/>
> ```javascript
> //我们上面的代码只是创建了两个相似对象，如果有10个，那得复制十遍，代码更加冗余
> //为此，我们可以创建一个集中例化的方法（函数）
> function girls(looks,family){
>     let girl = new Object();
>     girl.looks = looks;
>     girl.family = family;
>     girl.Cando = function(){
>       return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>     }
>     return girl;
> }
> 
> let girl1 = girls('very beautiful','富二代');  //创建第一个女朋友对象
> let girl2 = girls('非常漂亮','富二代有事业');   //创建第二个女朋友对象
> // CTRL + F5 深度刷新页面
> console.log(girl1.Cando());   //输出第一个女朋友对象实例的Cando()方法
> console.log(girl2.Cando());   //输出第二个女朋友对象实例的Cando()方法
> //我们发现，如果你想创建10个女朋友对象，只需要跟上面创建方式一样，传参即可，
> //解决了重复声明对象属性方法的操作，解决了代码的冗余
> ```
> 以上这种解决多个类似对象声明，实例化对象产生大量重复代码，我们创建一个集中实例化的方法（函数），这种方法，我们称之为：工厂模式的方法。<br/><br/>
> 但工厂模式有没有什么其他问题呢？
> ```javascript
> console.log(typeof girl1);//object
> console.log(typeof girl2);//object
> 
> console.log(girl1 instanceof Object);//true
> console.log(girl2 instanceof Object);//true
> 
> //问题来了，girl1 和 girl2 都是object类型，这样就搞不清楚它们到底是哪个对象的实例，产生了识别问题
> function _girls(looks,family){
>   let girl = new Object();
>   girl.looks = looks;
>   girl.family = family;
>   girl.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
>   return girl;
> }
> 
> let girl3 = _girls('天使面容','家里贫穷'); //创建第三个女朋友对象
> console.log(girl3.Cando());   //输出第三个女朋友对象实例的Cando()方法
> //问题来了，创建第三个女朋友对象是哪个对象你能搞清楚吗？
> console.log(girl3 instanceof Object);//因为girl3也是object
> //很明显girl3是用另外一个函数创建的，但是它们都是Object类型
> //就无法区分，谁到底是谁的对象
> //因为girl1，girl2是第一个工厂声明出来的object
> //girl3是第二个工厂声明出来的object
> //它们都是Object，无法区分它们属于哪个工厂声明出来的Object
> //那么如何识别它们属于哪个工厂声明出来的呢，我们下节课再讲
> ```


### ③ 构造函数(构造方法)创建特定的对象
> 上一节课我们讲了创建对象的工厂模式，讲到工厂模式集中实例化，但是遇到一个问题，就是没有办法识别某一个对象的引用，到底是哪一个的引用，哪一个对象。这个时候，就引申出另外一种创建对象的方式，叫做构造函数（构造方法）创建。
> ```javascript
> //构造函数创建对象
> function Girls(looks,family){//创建一个对象
>    //this代表的就是Girls这个对象
>    this.looks = looks;     //添加一个属性
>    this.family = family;   //添加一个属性
>    this.Cando = function(){
>      return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>    }
> }
> //创建第一个对象
> let girl1 = new Girls('very beautiful','富二代');
> //创建第二个对象
> let girl2 = new Girls('非常漂亮','富二代有事业');
> console.log(girl1.Cando());
> console.log(girl2.Cando());
> //解决了哪些问题？
> //1.解决了代码重复问题，确实解决了，可以执行，代码也不重复
> //2.解决了对象识别问题吗？
> console.log(girl1 instanceof Object);//true
> //注：所有构造函数的对象都是Object
> //关于说明识别问题，我们先看几个基础概念在讨论
> 
> //回到构造函数我们来看：
> //1. 构造函数我们并没有 new Object(); 工厂模式我们是new Object();
> //2. 构造函数没有 new Object(); 但它的后台会自动new Object();并传给了一个对象，如：let obj = new Object();
> //3. this相当于后台运行的obj
> //4. 构造函数不需要返回对象引用，它是后台自动返回的，我们的工厂模式最后需要返回我们声明的那个对象应用，
> 
> //构造函数创建的一些规范：
> //1.构造函数也是函数，但函数名第一个字母必须大写（以前）（虽然现在也可以小写不报错，但是我们还是要大写，便于区分普通函数）
> //2.必须使用new运算符，这个是必须new的，不使用new 就成普通函数了
> //3.必须通过 new 构造函数名()，如：new Girls()
> //实际上，它跟我们工程模式比，就是少了 let girl = new Object();return girl;然后将对象改成了this
> 
> //了解了上述概念后，我们来看一下它为什么可以解决识别问题？
> //1. 它是object  console.log(girl1 instanceof Object);//true
> //2. 当然它也是Girls, 什么意思呢：Girls其实也是一个对象啊，所以我们可以这么打印
> console.log(girl1 instanceof Girls);
> console.log(girl2 instanceof Girls);
> 
> 
> function _Girls(looks,family){//创建一个对象
>   //this代表的就是_Girls这个对象
>   this.looks = looks;     //添加一个属性
>   this.family = family;   //添加一个属性
>   this.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>   }
> }
> 
> //创建第三个对象
> let girl3 = new _Girls('天使面容','家庭贫穷');
> console.log(girl3.Cando());
> 
> //girl3属于哪个对象的构造函数？
> console.log(girl3 instanceof Girls);//false
> console.log(girl3 instanceof _Girls);//true
> //可以识别了，因为girl3是_Girls对象的引用，所以它返回true
> 
> //总结：使用构造函数的方法，即解决了重复实例化代码重复问题，又解决了对象识别的问题，
> //它比我们上一节课的工厂模式多了这些优点
> ```

### ④ 构造函数知识扩展，对象冒充构造函数，构造函数体内的函数返回值相等，但引用地址不相同
> ```javascript
> //构造函数创建对象
> function Girls(looks,family){//创建一个对象
>   //this代表的就是Girls这个对象
>   this.looks = looks;     //添加一个属性
>   this.family = family;   //添加一个属性
>   // this.Cando = function(){
>   //   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>   // }
>   this.Cando = cando;
> }
> 
> //回忆一下对象冒充
> let obj = new Object();
> // console.log(obj.Cando());//报错
> //冒充一下Girls对象
> Girls.call(obj,'天使面容','家里贫穷');
> console.log(obj.Cando());
> //obj对象具备了构造函数Girls对象的属性和方法
> 
> //探讨一下构造函数里面的方法的一些问题【知识扩展】
> let girl1 = new Girls('非常漂亮','富二代');
> let girl2 = new Girls('非常漂亮','富二代');
> console.log(girl1.looks == girl2.looks);//true
> console.log(girl1.Cando() == girl2.Cando());//true
> //构造函数体内方法的值是相等的
> 
> console.log(girl1.Cando);//构造函数体内方法的引用地址
> console.log(girl1.Cando == girl2.Cando);//false
> //发现它们返回的引用地址不相同，原因是：
> //let girl1 = new Girls('非常漂亮','富二代');//实例化后引用地址变了，比如第一次实例化引用地址是1
> //let girl2 = new Girls('非常漂亮','富二代');//第一次实例化引用地址是2了
> 
> //如果想让它们两个引用地址一致，可以采用把构造函数内部的方法通过全局来实现引用地址的一致
> function cando(){
>   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> 
> //当然这样又会有新的问题，就是放在全局，就可以直接调用了，会被恶意调用
> console.log(cando());//出现访问不到this.looks + this.family，它是NaN
> //所以我们上面说的把它拿出来放在全局，这个方式是不好的，还是应该放在构造函数内部，成为一个整体有封装的感觉
> //举这个例子，只是为了给大家扩展一下，构造函数体内的函数，在实例化后，引用地址不一样了
> //返回值是一样的，大家知道就行
> ```


















































































<br/><br/><br/><br/><br/><br/>

## 【第二学期第2季课程】其它章节
### [章节1.课程介绍](/secondless/w-b '章节1.课程介绍')
<!-- <LessList  /> -->
### [章节2.面向对象与原型](/secondless/w-b/面向对象与原型 '章节2.面向对象与原型')

## 其它学期课程
### [第一学期（学习顺序：01）](/aboutless.html '第一学期课程')
> 第一学期课程专为零基础的学员定制录制的，纯html+css做企业网站的网页，主讲html和css的相关基础知识，flex布局相关知识，封装css基础样式库，引入字体图标及网页开发基础布局思维，完成企业网站网页的开发过程。<br/><br/>
<b><a href="https://study.163.com/course/courseMain.htm?courseId=1213374826&share=2&shareId=480000002289674" target="_blank">[第一学期学习视频]</a>
</b>

### [第二学期【第1季】（学习顺序：02）](/secondless/w-a '第二学期第1季课程')
> 主讲JavaScript的基础，建议所有学员观看。<br/>
<b>
   <a href="/secondless/w-a.html" target="_blank">[第1季学习文档]</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   <a style="margin-left:20px;">[第1季学习视频]</a>
</b>

### [第二学期【第2季】（学习顺序：03）](/secondless/w-b '第二学期第2季课程')
> JavaScript中的面向对象，类，ajax，封装js库过渡到jQuery， vue.js基础配置网站页面，建议所有学员观看。<br/>
<b>
   <a href="/secondless/w-b.html" target="_blank">[第2季学习文档]</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   <a style="margin-left:20px;">[第2季学习视频]</a>
</b>