---
navbar: true
sidebar: auto
title: 章节2.面向对象与原型 
---

前言
> 1. 关于基础 <br/>
> 本章节开始讲js中的面向对象与原型，需要有一定的基础，对于零基础学员，只需要按照我们的课程学习顺序学下来即可，对于有一定基础直接开始学习本季度课程的同学，如果在学习的过程感觉很吃力，说明你的js基础还不牢靠，那么建议你回去学习一下我们第二学期第1季的课程。 <br/> <br/>
> 2. 关于课件和资料  <br/>
> 大家直接去查看我们视频的第三课，里面告诉大家学习资料下载和学习文档地址，之后我们在课程中就不再提及了。<br/> <br/>
> 3. 课前准备  <br/>
> 本期课程会学习到ajax相关技术，需要用到搭建本地服务器<br/><br/>
> ① 如果你是从第二学期第1季学习过来的同学，无需课前准备，因为我们继续沿用上一季的代码及搭建的本地服务器。<br/><br/>
> ② 如果你是有一定基础直接学习本季课程的同学，首先需要去群文件里面下载本节课的课件【第二学期第2季课前代码】（也就是我们第1季的代码），然后需要搭建本地服务器（我们在上一季课程讲了两种搭建本地服务器的方法，为了便于统一学习，因为有的同学使用的是window系统，有的同学使用的是苹果电脑，我们统一使用的是UPUPWANK软件搭建的本地服务器）<br/><br/>
> 具体步骤查看第二学期第1季视频： <a href="javascipt(void:0);" target="_blank" title="搭建本地服务器点击查看">搭建本地服务器</a> <br/>
> 开发工具使用的是vscode，具体安装： <a href="https://study.163.com/course/courseLearn.htm?courseId=1213374826&share=2&shareId=480000002289674#/learn/video?lessonId=1285001250&courseId=1213374826" target="_blank" title="安装vscode(第一学期视频第1课)点击查看">安装vscode(第一学期视频第1课)</a>


## Ⅰ、创建对象
### ① 创建对象，剖析问题
> ```javascript
> let girl = new Object(); //new 方式
> //let girl = Object(); // new 关键字可以省略
> girl.height = '170cm'; // 分号，创建属性字段，等于号右边是值
> girl.weight = '52kg';
> girl.age = 25;         //数值
> girl.looks = 'very beautiful';
> girl.bust = '90cm';
> girl.waist = '60cm';
> girl.hip = '90cm';
> girl.education = '研究生以上学历';
> girl.family = '富二代';
> //对象中的函数（方法）
> girl.Cando = function(){
>     return '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
> }
> console.log(girl);
> console.log(girl.looks);//属性
> console.log(girl.Cando());//方法
> 
> //此时改动一下方法
> girl.Cando = function(){
>   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   //this表示当前作用域下的对象，this代表的就是girl对象
>   //this表示new Object()实例化出来的那个对象
>   //this要放在一个作用域下，比如 girl.Cando = function(){}
>   //function(){} 就是box作用域下的方法，方可用this，来表示girl本身
> }
> console.log(girl.Cando());//方法
> 
> 
> 
> //console.log(this);//window
> // var height = '180cm';
> // console.log(this.height);
> 
> //现在问题是，如果我想创建一个类似的对象，怎么写？
> 
> // let girl2 = new Object(); //new 方式
> //let girl2 = Object(); // new 关键字可以省略
> let girl2 = girl;
> girl2.height = '180cm'; // 分号，创建属性字段，等于号右边是值
> girl2.weight = '52kg';
> girl2.age = 25;         //数值
> girl2.looks = 'very beautiful';
> girl2.bust = '100cm';
> girl2.waist = '60cm';
> girl2.hip = '90cm';
> girl2.education = '硕士以上学历';
> girl2.family = '富二代有企业';
> //对象中的函数（方法）
> girl2.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心，天天哄我！';
> }
> 
> console.log(girl2.Cando());//方法
> 
> //发现代码写了一大段，两个对象大部分属性和方法都是相同的？
> //另外发现 let girl2 = girl;
> 
> console.log(girl.Cando());
> console.log(girl2.Cando());
> //两个结果一样了，girl对象的方法改变了，原因大家知道，girl2的方法替换了girl对象的方法，因为它们指向的都是同一个对象，基础章节讲过了
> //两种方式都不行，代码都会有重复，那么有没有什么办法来避免重复这么多代码呢，答案是有的，我们下节课讲
> ```

### ② 传统面向对象：工厂模式
> 我们上一节课通过案例说明了，不管你是通过new Object()创建一个类似对象，还是将第一个对象赋值给第二个变量，都无法解决代码重复冗余问题。聪明的同学，可能会马上想到一种办法，就是写一个函数，因为函数可以传参，并且函数可以被多次调用，我们来写一下，看能不能解决。<br/>
> ```javascript
> //我们上面的代码只是创建了两个相似对象，如果有10个，那得复制十遍，代码更加冗余
> //为此，我们可以创建一个集中例化的方法（函数）
> function girls(looks,family){
>     let girl = new Object();
>     girl.looks = looks;
>     girl.family = family;
>     girl.Cando = function(){
>       return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>     }
>     return girl;
> }
> 
> let girl1 = girls('very beautiful','富二代');  //创建第一个女朋友对象
> let girl2 = girls('非常漂亮','富二代有事业');   //创建第二个女朋友对象
> // CTRL + F5 深度刷新页面
> console.log(girl1.Cando());   //输出第一个女朋友对象实例的Cando()方法
> console.log(girl2.Cando());   //输出第二个女朋友对象实例的Cando()方法
> //我们发现，如果你想创建10个女朋友对象，只需要跟上面创建方式一样，传参即可，
> //解决了重复声明对象属性方法的操作，解决了代码的冗余
> ```
> 以上这种解决多个类似对象声明，实例化对象产生大量重复代码，我们创建一个集中实例化的方法（函数），这种方法，我们称之为：工厂模式的方法。<br/><br/>
> 但工厂模式有没有什么其他问题呢？
> ```javascript
> console.log(typeof girl1);//object
> console.log(typeof girl2);//object
> 
> console.log(girl1 instanceof Object);//true
> console.log(girl2 instanceof Object);//true
> 
> //问题来了，girl1 和 girl2 都是object类型，这样就搞不清楚它们到底是哪个对象的实例，产生了识别问题
> function _girls(looks,family){
>   let girl = new Object();
>   girl.looks = looks;
>   girl.family = family;
>   girl.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
>   return girl;
> }
> 
> let girl3 = _girls('天使面容','家里贫穷'); //创建第三个女朋友对象
> console.log(girl3.Cando());   //输出第三个女朋友对象实例的Cando()方法
> //问题来了，创建第三个女朋友对象是哪个对象你能搞清楚吗？
> console.log(girl3 instanceof Object);//因为girl3也是object
> //很明显girl3是用另外一个函数创建的，但是它们都是Object类型
> //就无法区分，谁到底是谁的对象
> //因为girl1，girl2是第一个工厂声明出来的object
> //girl3是第二个工厂声明出来的object
> //它们都是Object，无法区分它们属于哪个工厂声明出来的Object
> //那么如何识别它们属于哪个工厂声明出来的呢，我们下节课再讲
> ```


### ③ 构造函数(构造方法)创建特定的对象
> 上一节课我们讲了创建对象的工厂模式，讲到工厂模式集中实例化，但是遇到一个问题，就是没有办法识别某一个对象的引用，到底是哪一个的引用，哪一个对象。这个时候，就引申出另外一种创建对象的方式，叫做构造函数（构造方法）创建。
> ```javascript
> //构造函数创建对象
> function Girls(looks,family){//创建一个对象
>    //this代表的就是Girls这个对象
>    this.looks = looks;     //添加一个属性
>    this.family = family;   //添加一个属性
>    this.Cando = function(){
>      return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>    }
> }
> //创建第一个对象
> let girl1 = new Girls('very beautiful','富二代');
> //创建第二个对象
> let girl2 = new Girls('非常漂亮','富二代有事业');
> console.log(girl1.Cando());
> console.log(girl2.Cando());
> //解决了哪些问题？
> //1.解决了代码重复问题，确实解决了，可以执行，代码也不重复
> //2.解决了对象识别问题吗？
> console.log(girl1 instanceof Object);//true
> //注：所有构造函数的对象都是Object
> //关于说明识别问题，我们先看几个基础概念在讨论
> 
> //回到构造函数我们来看：
> //1. 构造函数我们并没有 new Object(); 工厂模式我们是new Object();
> //2. 构造函数没有 new Object(); 但它的后台会自动new Object();并传给了一个对象，如：let obj = new Object();
> //3. this相当于后台运行的obj
> //4. 构造函数不需要返回对象引用，它是后台自动返回的，我们的工厂模式最后需要返回我们声明的那个对象应用，
> 
> //构造函数创建的一些规范：
> //1.构造函数也是函数，但函数名第一个字母必须大写（以前）（虽然现在也可以小写不报错，但是我们还是要大写，便于区分普通函数）
> //2.必须使用new运算符，这个是必须new的，不使用new 就成普通函数了
> //3.必须通过 new 构造函数名()，如：new Girls()
> //实际上，它跟我们工程模式比，就是少了 let girl = new Object();return girl;然后将对象改成了this
> 
> //了解了上述概念后，我们来看一下它为什么可以解决识别问题？
> //1. 它是object  console.log(girl1 instanceof Object);//true
> //2. 当然它也是Girls, 什么意思呢：Girls其实也是一个对象啊，所以我们可以这么打印
> console.log(girl1 instanceof Girls);
> console.log(girl2 instanceof Girls);
> 
> 
> function _Girls(looks,family){//创建一个对象
>   //this代表的就是_Girls这个对象
>   this.looks = looks;     //添加一个属性
>   this.family = family;   //添加一个属性
>   this.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>   }
> }
> 
> //创建第三个对象
> let girl3 = new _Girls('天使面容','家庭贫穷');
> console.log(girl3.Cando());
> 
> //girl3属于哪个对象的构造函数？
> console.log(girl3 instanceof Girls);//false
> console.log(girl3 instanceof _Girls);//true
> //可以识别了，因为girl3是_Girls对象的引用，所以它返回true
> 
> //总结：使用构造函数的方法，即解决了重复实例化代码重复问题，又解决了对象识别的问题，
> //它比我们上一节课的工厂模式多了这些优点
> ```

### ④ 构造函数知识扩展，对象冒充构造函数，构造函数体内的函数返回值相等，但引用地址不相同
> ```javascript
> //构造函数创建对象
> function Girls(looks,family){//创建一个对象
>   //this代表的就是Girls这个对象
>   this.looks = looks;     //添加一个属性
>   this.family = family;   //添加一个属性
>   // this.Cando = function(){
>   //   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>   // }
>   this.Cando = cando;
> }
> 
> //回忆一下对象冒充
> let obj = new Object();
> // console.log(obj.Cando());//报错
> //冒充一下Girls对象
> Girls.call(obj,'天使面容','家里贫穷');
> console.log(obj.Cando());
> //obj对象具备了构造函数Girls对象的属性和方法
> 
> //探讨一下构造函数里面的方法的一些问题【知识扩展】
> let girl1 = new Girls('非常漂亮','富二代');
> let girl2 = new Girls('非常漂亮','富二代');
> console.log(girl1.looks == girl2.looks);//true
> console.log(girl1.Cando() == girl2.Cando());//true
> //构造函数体内方法的值是相等的
> 
> console.log(girl1.Cando);//构造函数体内方法的引用地址
> console.log(girl1.Cando == girl2.Cando);//false
> //发现它们返回的引用地址不相同，原因是：
> //let girl1 = new Girls('非常漂亮','富二代');//实例化后引用地址变了，比如第一次实例化引用地址是1
> //let girl2 = new Girls('非常漂亮','富二代');//第一次实例化引用地址是2了
> 
> //如果想让它们两个引用地址一致，可以采用把构造函数内部的方法通过全局来实现引用地址的一致
> function cando(){
>   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> 
> //当然这样又会有新的问题，就是放在全局，就可以直接调用了，会被恶意调用
> console.log(cando());//出现访问不到this.looks + this.family，它是NaN
> //所以我们上面说的把它拿出来放在全局，这个方式是不好的，还是应该放在构造函数内部，成为一个整体有封装的感觉
> //举这个例子，只是为了给大家扩展一下，构造函数体内的函数，在实例化后，引用地址不一样了
> //返回值是一样的，大家知道就行
> ```

## Ⅱ、原型
> 我们创建的每个函数都有一个 prototype(原型)属性，就是说我们创建函数对象的时候，它里面默认就有一个prototype(原型)属性，它是自动生成的。而这个属性又是一个对象，就是说这个对象下面有一个属性，这个属性其实是另外一个对象的引用。它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解：prototype 通过调用构造函数而创建的那个对象的原型对象。使用原型的好处可以让所有对象实例共享它所
包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。
### ① 原型创建对象
> ```javascript
> /*
> //构造函数创建对象
> function Girls(looks,family){//创建一个对象
>   //this代表的就是Girls这个对象
>   this.looks = looks;     //实例属性   
>   this.family = family;   //实例属性
>   this.Cando = function(){ //实例方法
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
>   }
> }
> */
> 
> //原型来创建对象
> function Girls(){}  //构造函数体内什么都没有，这里如果有，叫做实例属性，实例方法
> //那么既然有实例方法和实例属性，那么就有原型方法和原型属性
> //我们说：我们创建的每个函数都有一个 prototype(原型)属性，这个属性是一个对象
> Girls.prototype.looks = '超级漂亮';  //原型属性
> Girls.prototype.family = '富二代';   //原型属性
> Girls.prototype.Cando = function(){ //原型方法
>   return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> //调用的方式还是一样的
> let girl1 = new Girls();
> console.log(girl1.looks);
> console.log(girl1.family);
> console.log(girl1.Cando());
> 
> //那么问题来了，我们用原型属性原型方法，和上面的我们用实例属性，实例方法有什么区别？
> //区别就是：共享
> //那么共享有什么用呢？所谓共享，就是Girls里面的属性和方法保持一致
> //那么保持一致的话，我们用什么来检测呢
> //上一节课，我们讲了构造函数在实例化的时候，它里面的方法，引用地址是不一样的，自身实例化也不相等
> //如果是原型方法，那么它们的引用地址是共享的，大家都是一样的
> let girl2 = new Girls();
> console.log(girl1.Cando == girl2.Cando);//true
> //也就是说，你如果用的原型属性和方法，那么它们的引用地址是一样的，是共享的
> //我们本节课先通过代码给大家解释了构造函数和原型它们的区别
> //下节课我们将通过图片在给大家直观的解释，本节课大家先慢慢消化，理解实例属性实例方法，原型属性原型方法
> ```


### ② 构造函数与原型对比，深度解析（图片示例）
> 构造函数声明方式
<img src="https://docs-51yrc-com.oss-cn-hangzhou.aliyuncs.com/docs-imgs/2-2-2-01.jpg" alt="window 对象" class="zoom-custom-imgs" 
style="display:inline-block;" /> 
> 
> 解读：
> 1. girl1, girl2 对象的引用，声明了构造函数 new Girls('非常漂亮','富二代'); 图片中它们参数一样，好用于做对比；<br/>
> 2. 在内存中分别分配了两个区间，引用地址1，引用地址2，很明显它们的实例（这两个区间）是不共享；<br/>
> 3. 然后每个里面有实例属性，实例方法；<br/>
> 4. 其实从图片中可以看到，它们里面的looks属性，family属性，其实它们的地址都不一样，只不过不好测试（我们讲的时候，只是对比了它们的值而已），而它们的这个Cando方法比较好测试，所以当时我们就测试了它们的Function引用地址，得到它们引用地址不相同，其实它们整个引用：girl1,girl2，引用地址都不是不相同的，所以 我们比较 girl1 == girl2,不管是相等，还是恒等，都是false。

> 原型模式声明
<img src="https://docs-51yrc-com.oss-cn-hangzhou.aliyuncs.com/docs-imgs/2-2-2-02.jpg" alt="window 对象" class="zoom-custom-imgs" 
style="display:inline-block;" /> 
> 
> 解读：
> 1. girl1你通过new Girls();用了原型，girl2你也通过new Girls();用了原型。就是说你的这个girl1,girl2实例还是有的，只不过这两个实例里面是空的;
> 2. 虽说里面是空的，但是里面有自带的一个属性__proto__,两个都有，然后它们是如何访问到原型的呢：我们可以回顾（我们创建的每个函数都有一个 prototype(原型)属性，这个属性又是一个对象），可以试着输出一下girl1.prototype;
> 3. 发现结果是undefined，为什么是undefined？它有这个属性，但是这个属性不在这里访问，它应该访问这个指针：\__proto__；
> 4. 我们可以通过图片清晰看到，我们这两块区间，虽然是空的，它里面有一个__proto__属性，这个属性其实就是prototype，只不过是后面prototype对象的一个指针属性；
> 5. 也就是说你实例化了这个Girls之后，你就会有这么一个属性__proto__，而这个属性__proto__会直接引向你这个prototype对象；
> 6. 回到前面（而这个属性prototype又是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法），也就是说prototype即是一个属性，也是一个对象，我们将prototype这一块放在后面当做一个对象new出来，然后通过__proto__指针指向它，因此，通过girl1.prototype访问不到，需要通过 girl1.__proto__访问；通过这个指针指向prototype原型对象；
> 7. 另外，我们发现在prototype原型对象里面有一个constructor属性，这是原型里面的一个属性。也就是在原型模式声明中，多了两个属性：\__proto__ 和 constructor，这两个属性都是创建对象时自动生成的。通过__proto__属性指针，指向构造函数Girls原型里面的（prototype原型对象里面的）constructor属性，constructor属性也叫构造属性；因此我们可以：girl1.constructor; 会输出构造函数本身，它的作用是：被原型指针定位，得到构造函数本身（其实就是做一个连接的作用，即对象实例对应的原型对象的连接作用，就是说它们两个之间互相关联的一个作用），图上也能看到：中间部分是实例，后面Girls prototype是原型部分；
> 8. 通过属性__proto__、constructor属性就可以访问到原型里面的属性和方法了：可以访问如：girl1.looks，因为里面有两个后台属性__proto__、constructor，把它们进行串联了，串联之后就可以进行引用了，这是后台功能。<br/>

> ```javascript
> console.log(girl1.prototype);//这个属性是对象，访问不到
> console.log(girl1.__proto__);//这个属性是一个指针，指向prototype原型对象里面的构造属性constructor
> console.log(girl1.constructor);//构造属性，可以获取构造函数本身： function Girls(){}
>                                //作用是被原型指定定位，然后得到构造函数本身
>                                //其实就是对象实例girl1对应原型prototype对象的作用
> 
> //在原型模式声明中，通过__proto__，constructor后台自动创建的这两个属性的相关关联，就可以获取原型对象里面的属性和方法了
> console.log(girl1.looks);
> console.log(girl1.family);
> console.log(girl1.Cando());
> ```

在搞清楚了上面的底层逻辑后，现在判断一个对象实例（对象引用）如girl1，是不是指向了构造函数Girls的原型对象? <br/>

### ③ isPrototypeOf()方法：判断一个对象是否指向了该构造函数的原型对象
> <b>基本上，只要实例化了的，它会自动指向它的原型对象。</b>
> ```javascript
> //判断实例化对象girl1是否指向该构造函数Girls的原型对象
> //我们的图示讲了半天，就是说的指向问题，确实是指向了它的原型对象，是通过后台自动创建的是属性__proto__指针指向的
> //因此，基本上，只要实例化了，都自动指向了它构造函数的原型对象
> console.log(Girls.prototype.isPrototypeOf(girl1));
> //我们上面的代码，的确有原型，所以是true
> 
> //现在来一个没有写原型的
> let obj = new Object(); 
> //虽然实例化了，但是后台有没有原型不知道，可以判断
> console.log(Object.prototype.isPrototypeOf(obj));//true
> //在一次印证，只要实例化了，它就默认指向了它的原型
> 
> //那obj有没有指向Girls构造函数里面的原型呢
> //大家一看就知道，肯定没有指向啊
> console.log(Girls.prototype.isPrototypeOf(obj));
> ```
注：以上老师通过图片示意，剖析了一下构造函数、原型偏底层的一些原理，目的是为了让大家对它们有更深刻的理解 <br/>
本节课听一遍没有听懂的同学，就多听两遍，慢慢你就懂了，这个一定要搞懂

### ④ 原型模式的执行流程（顺序）：先实例，在构造函数，最后原型
> 如果原型上面有原型属性looks, 实例上面也有属性looks, 怎么执行
<img src="https://docs-51yrc-com.oss-cn-hangzhou.aliyuncs.com/docs-imgs/2-2-2-03.jpg" alt="window 对象" class="zoom-custom-imgs" 
style="display:inline-block;" /> 

> ```javascript
> girl1.looks = '天使面容';//实例属性，并没有重写原型属性
> console.log(girl1.looks);//'天使面容' 就近原则
> 
> girl2.looks = '长相一般';
> console.log(girl2.looks);//'长相一般'
> 
> //理解就近原则
> //原型来创建对象
> function Girls(){ //构造函数体内什么都没有，这里如果有，叫做实例属性，实例方法
>   this.looks = '天使面容';
> } 
> Girls.prototype.looks = '非常漂亮';//原型属性
> Girls.prototype.family = '富二代';//原型属性
> Girls.prototype.Cando = function(){ //原型方法
>  return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> 
> //没有给实例重写赋值，则找构造函数里面的实例，有则返回，没有则找原型
> let girl1 = new Girls();
> console.log(girl1.looks);//'天使面容'
> let girl2 = new Girls();
> console.log(girl2.looks);//'天使面容'
> 
> 
> //给girl1实例赋值：此时（实例、构造函数、原型都有looks属性）
> //就近原则
> girl1.looks = '御姐脸型';
> console.log(girl1.looks);//'御姐脸型'
> //实例属性不会共享，独有的，所以不影响其他实例
> //girl2实例，查找顺序：先构造函数--->原型
> console.log(girl2.looks);//'天使面容'
> ```

原型模式的执行流程：<br/>
① 实例属性（方法） ----> ② 构造函数属性（方法） ---> ③ 原型属性（方法）


### ⑤ 删除实例属性访问原型属性：delete方法
> ```javascript
> let girl1 = new Girls();
> girl1.looks = '御姐脸型';
> console.log(girl1.looks);
> //实例属性不会共享，独有的，所以不影响其他实例
> //girl2实例，查找顺序：先构造函数--->原型
> 
> let girl2 = new Girls();
> console.log(girl2.looks);//天使面容
> ```
> 访问了实例之后，又想访问原型属性，怎么做
> ```javascript
> let girl1 = new Girls();
> girl1.looks = '御姐脸型';
> console.log(girl1.looks);//'御姐脸型'
> 
> delete girl1.looks;//删除实例属性，包括构造函数里面的实例属性
> console.log(girl1.looks);//'非常漂亮'
> 
> //删除原型属性（不常用）
> //delete Girls.prototype.looks;
> //console.log(girl1.looks);
> 
> //覆盖原型中的属性（不常用）
> Girls.prototype.looks = '萝莉型';
> console.log(girl1.looks);//'萝莉型'
> ```

如何判断一个属性是在实例中，还是在原型中?
### ⑥ hasOwnProperty()方法检测属性是否存在实例中，in操作符判断属性是否存在于实例或原型中，两者结合判断属性是否只存在原型中
> #### hasOwnProperty()方法，主要用于判断某个属性是否在实例中
> ```javascript
> //原型来创建对象
> function Girls(){//构造函数体内什么都没有，这里如果有，叫做实例属性，实例方法
>   this.looks = '天使面容';
> } 
> Girls.prototype.looks = '非常漂亮';//原型属性
> Girls.prototype.family = '富二代';//原型属性
> Girls.prototype.Cando = function(){ //原型方法
>  return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> //没有给实例重写赋值，则找构造函数里面的实例，有则返回，没有则找原型
> let girl1 = new Girls();
> girl1.looks = '御姐脸型';
> console.log(girl1.hasOwnProperty('looks'));//实例里有返回 true，否则返回 false
> ```
> 
> #### in 操作符
> 判断对象的某个属性，是否存在于实例里面或者原型里面，任何一个里面有，都返回true
> ```javascript
> console.log('looks' in girl1);//true
> console.log('family' in girl1);//true
> console.log('sex' in girl1);//false
> girl1.sex = '女';
> console.log('sex' in girl1);//true
> ```
> #### 判断原型中是否存在属性：结合in和hasOwnProperty方法进行判断
> ```javascript
> function isProperty(object, property) { //判断原型中是否存在属性
>   return (property in object) && !object.hasOwnProperty(property);
> }
> console.log(isProperty(girl1,'family'));//true 原型有
> girl1.sex = '女';
> console.log(isProperty(girl1,'sex'));//false 原型没有
> console.log(girl1.hasOwnProperty('sex'));//true 实例有
> ```


### ⑦ 原型创建对象字面量声明方式
> 为了让属性和方法更好的体现封装的效果，并且减少不必要的输入，原型的创建可以使用字面量的方式
> ```javascript
> /*
> //原型来创建对象
> function Girls(){}//构造函数体内什么都没有，这里如果有，叫做实例属性，实例方法
> Girls.prototype.looks = '非常漂亮';//原型属性
> Girls.prototype.family = '富二代';//原型属性
> Girls.prototype.Cando = function(){ //原型方法
>  return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> let girl1 = new Girls();
> console.log(girl1.prototype);//undefined 使用对象实例无法访问到prototype
> console.log(girl1.__proto__);//使用对象实例的指针__proto__访问到prototype
> //但是，我们还可以使用函数名（对象名）访问prototype
> console.log(Girls.prototype);
> */
> 
> //字面量方式创建原型对象
> function Girls() { }
> Girls.prototype = { // {}就是对象（对象字面量创建），跟 new Object()一个意思
>   looks: '非常漂亮',
>   family: '富二代',
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> let girl1 = new Girls();
> console.log(girl1.looks);
> console.log(girl1.Cando());
> ```
> 使用构造函数创建原型对象和使用字面量创建原型对象在 <br/>
> <b>使用上基本相同</b><br/>
> 但还是有一些区别:<br/>
> 字面量创建的方式使用 constructor 属性不会指向实例，而会指向 Object，构造函数创建的方式则相反<br/>
> ```javascript
> //原型来创建对象
> function Girls(){}//构造函数体内什么都没有，这里如果有，叫做实例属性，实例方法
> Girls.prototype.looks = '非常漂亮';//原型属性
> Girls.prototype.family = '富二代';//原型属性
> Girls.prototype.Cando = function(){ //原型方法
>  return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！'; 
> }
> let girl1 = new Girls();
> console.log(girl1.constructor);//function Girls(){} 构造函数本身
> console.log(girl1.constructor == Girls);//true
> 
> //字面量方式创建原型对象
> function Girls() { }
> Girls.prototype = { // {}就是对象（对象字面量创建），跟 new Object()一个意思
>   looks: '非常漂亮',
>   family: '富二代',
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> let girl1 = new Girls();
> console.log(girl1.constructor);// function Object(){ [native code] }
> //原因：正常构造函数原型模式创建对象，实例对象__proto__指向原型对象constructor构造属性，
> //constructor构造属性反过来指向构造函数本身，没什么问题
> 
> //但是我们通过Girls.prototype = {};字面量创建，这种写法其实就是创建了一个新对象，
> //而每创建一个函数，就会同时创建它 prototype
> //这个对象也会自动获取 constructor 属性
> //所以，新对象的 constructor 重写了 Girls 原来的 constructor
> //因此会指向新对象
> //那个新对象没有指定构造函数，那么就默认为 Object
> 
> console.log(girl1.constructor == Girls);//false
> console.log(girl1.constructor == Object);//true
> ```
那么怎么样让 girl1.constructor指向Girls呢？可以强制指向
> ```javascript
> //字面量方式创建原型对象
> function Girls() { }
> Girls.prototype = { // {}就是对象（对象字面量创建），跟 new Object()一个意思
>   constructor:Girls, //强制指向
>   looks: '非常漂亮',
>   family: '富二代',
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> let girl1 = new Girls();
> console.log(girl1.constructor);//function Girls() {}
> 
> console.log(girl1.constructor == Girls);//true
> console.log(girl1.constructor == Object);//false
> ```


### ⑧ 原型创建对象字面量声明方式，原型的声明是有先后顺序，重写原型会覆盖（切断）之前的原型
> ```javascript
> //字面量方式创建原型对象
> function Girls() { }
> Girls.prototype = {  // {}就是对象（对象字面量创建），跟 new Object()一个意思
>   constructor: Girls, //强制指向
>   looks: '非常漂亮',
>   family: '富二代',
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> //重写原型对象
> Girls.prototype = {
>   sex:'女'
> };
> let girl1 = new Girls();
> console.log(girl1.looks);
> //重写前： '非常漂亮'
> //重写后：undefined
> console.log(girl1.__proto__);// {sex:'女'}
> //把原来的原型对象和构造函数对象实例之间的关系切断了
> 
> //重写会带来这个问题，需要注意
> ```


### ⑨ 内置引用类型：String,Number,Array等本身也使用了原型
> ```javascript
> let arr = [1,56,3,98,1];
> //数组排序
> console.log(arr.sort());//[1,1,3,56,98]
> //sort排序不够严谨，我们在基础课程讲过了，但这个不是本节课重点
> //请问sort方法哪里来的？
> //现在你就可以这么找了
> //查看sort是否是Array原型对象里面的方法
> console.log(Array.prototype.sort);// function sort(){[native code]}
> //说明它是的
> console.log(Array.prototype.sort1);// undefined
> 
> console.log(Array.prototype);
> ```
> ```javascript
> console.log(String.prototype);
> let text = '迪丽热巴';
> console.log(text.substring('2'));//热巴
> //这样的话，我们也可以扩展String原型里面的方法
> //比如说，你要扩展一个方法addstring
> //先看一下原型里面有没有这个方法，没有的话我就添加一个
> console.log(String.prototype.addstring);//undefined
> 
> //给字符串的原型对象添加一个addstring方法
> String.prototype.addstring = function(){
>    return this + '真漂亮';
> }
> console.log(text.addstring());//'迪丽热巴真漂亮'
> //上面的this就是text
> //以上叫内置引用类型的功能扩展
> ```
> 尽管给原生的内置引用类型添加方法使用起来特别方便，但我们不推荐使用这种方法。因为它可能会导致命名冲突，不利于代码维护。我们主要作为了解即可，加深对原型的认识。<br/>
> 有的同学就会说，这原型模式很牛嘛，连内置对象都用原型，那么原型模式创建对象有没有什么缺点呢，下节课探讨！

### ⑩ 原型创建对象缺点剖析：传参和引用共享问题
> 原型模式创建对象也有自己的缺点，它省略了构造函数传参初始化这一过程，带来的缺点就是初始化的值都是一致的。
> ```javascript
> function Girls() { }
> Girls.prototype = {  
>   constructor: Girls, //强制指向
>   looks: '非常漂亮',
>   family: '富二代',
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> //省略了构造函数传参，导致原型里面初始化的值都是一样的
> //所以我实例化两个对象的时候，原型里面的值没办法修改的，根据不同情况进行修改，不能够保持独立，因为它们是共享的
> ```
> 原型最大的缺点就是它最大的优点，那就是共享。<br/>
> 原型中所有属性是被很多实例共享的，共享对于函数非常合适，对于包含基本值的属性也还可以。但如果属性包含引用类型，就存在一定的问题：
> ```javascript
> function Girls() { }
> Girls.prototype = {  
>   constructor: Girls, //强制指向
>   looks: '非常漂亮',
>   family: '富二代',
>   loves:['给我洗衣','做饭','陪我打游戏'], //数组，是个引用类型
>   Cando: function () {
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
> };
> //问题1：实例化对象的时候，没有办法通过传参来改变原型里面的值
> let girl1 = new Girls();//因为构造函数不需要传参，没办法通过传参修改实例化对象girl1
> console.log(girl1.loves);//['给我洗衣','做饭','陪我打游戏']
> //因此在实例化第二个对象的时候，没办法说 loves还有['天天哄我','给我端茶倒水']
> let girl2 = new Girls();
> console.log(girl2.loves);//['给我洗衣','做饭','陪我打游戏']
> 
> //那有的同学就会想到，实例化对象之后，不是可以设置实例属性吗
> girl2.loves.push('天天哄我','给我端茶倒水');
> console.log(girl2.loves);//看似可以
> //共享对于函数非常合适，对于包含基本值的属性也还可以。但如果属性包含引用类型，就存在一定的问题：
> //以上添加的两个爱好：'天天哄我','给我端茶倒水' 添加到了girl2对象的实例上了，实例属性
> 
> //那么思考，如果现在我实例化第三个对象，那么输出的loves是原型里面的，还是：
> //['给我洗衣','做饭','陪我打游戏','天天哄我','给我端茶倒水']
> let girl3 = new Girls();
> console.log(girl3.loves);
> //发现共享了girl2实例添加后的引用类型的原型
> //那么共享就带来了问题:
> //1. 构造函数不能传参；
> //2. 引用类型在前一个girl2实例化修改后，保持了共享，导致后面实例的girl3输出的时候，输出girl2的loves
> //共享是优点，但在本程序，girl3不应该加上['天天哄我','给我端茶倒水']，应该只初始化原型里面的loves
> //就又变成缺点了
> //那么如何解决这两个缺点呢？
> ```

### ⑪ 组合构造函数+原型模式：解决 ⑩ 构造传参和引用共享问题
> ```javascript
> //需要独立不共享的部分放在构造函数
> function Girls(looks,family,love) { 
>   this.looks = looks;
>   this.family =  family;
>   this.loves = ['给我洗衣','做饭','陪我打游戏'].concat(love);
> }
> //共享的使用原型
> Girls.prototype = {
>   constructor: Girls, //强制指向
>   //为什么Cando放共享，因为Cando放在构造函数里面，每次实例化，会开辟一个新的引用地址来存放这个方法
>   //这样就会大量占用内存，但是这些Cando效果都是一样的，都是返回下面这句话，不需要保持独立，放一个内存里面即可
>   //因此放在原型里面，这样可以大大节约内存
>   Cando: function () {
>     return this.looks + this.family + this.loves;
>   }
> }
> //用上面的方式，又保持了独立和共享，又解决了传参
> let girl1 = new Girls('非常漂亮','富二代','天天哄我');
> console.log(girl1.looks);//非常漂亮
> console.log(girl1.Cando());//非常漂亮富二代给我洗衣,做饭,陪我打游戏,天天哄我
> 
> let girl2 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl2.looks);//长相甜美
> console.log(girl2.Cando());//长相甜美富家千金给我洗衣,做饭,陪我打游戏,给我端茶倒水
> 
> girl2.loves.push('给我捶背');
> console.log(girl2.Cando());//长相甜美富家千金给我洗衣,做饭,陪我打游戏,给我端茶倒水,给我捶背
> 
> let girl3 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl3.Cando());//长相甜美富家千金给我洗衣,做饭,陪我打游戏,给我端茶倒水
> //发现girl3没有共享girl2实例化修改后的内容，保持了独立
> //因为我们的引用类型loves数组，放在了我们的构造函数里面，没有放在原型里面，没有共享，保持了独立，达到要求
> ```
> 这种混合模式很好的解决了传参和引用共享的大难题。是创建对象比较好的方法。但，这种写法没有给人一种封装的感觉，上面的写法其实是两个整体，构造函数 + 原型两块代码，能不能让它们写在一起，成为一个整体，有一种封装的感觉？

### ⑫ 动态原型模式：解决 ⑪ 组合构造函数+原型模式，代码封装在一起，一种封装的感觉
> 青铜版本
> ```javascript
> //青铜版本
> function Girls(looks,family,love) { 
>   this.looks = looks;
>   this.family =  family;
>   this.loves = ['给我洗衣','做饭','陪我打游戏'].concat(love);
> 
>   console.log('原型初始化开始');
>   Girls.prototype.Cando = function(){
>     return this.looks + this.family + this.loves;
>   }
>   console.log('原型初始化结束');
> 
> }
> 
> let girl1 = new Girls('非常漂亮','富二代','天天哄我');
> console.log(girl1.Cando());//非常漂亮富二代给我洗衣,做饭,陪我打游戏,天天哄我
> 
> let girl2 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl2.Cando());//长相甜美富家千金给我洗衣,做饭,陪我打游戏,给我端茶倒水
>
> let girl3 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl3.Cando());//长相甜美富家千金给我洗衣,做饭,陪我打游戏,给我端茶倒水
> 
> //为什么说是青铜版本?
> // 原型初始化了多次，没必要，初始化只需要一次即可，没必要每次构造函数实例化的时候都初始化
> ```
> 王者版本
> ```javascript
> //王者版本
> function Girls(looks,family,love) { 
>   this.looks = looks;
>   this.family =  family;
>   this.loves = ['给我洗衣','做饭','陪我打游戏'].concat(love);
> 
>   //只需要判断原型函数是否存在，不存在则初始化，存在则不用在执行
>   if(typeof this.Cando != 'function'){
>     console.log('原型初始化开始');
>     Girls.prototype.Cando = function(){
>       return this.looks + this.family + this.loves;
>     }
>     console.log('原型初始化结束');
>   }
>   
> }
> 
> let girl1 = new Girls('非常漂亮','富二代','天天哄我');
> console.log(girl1.Cando());
> 
> let girl2 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl2.Cando());
> 
> let girl3 = new Girls('长相甜美','富家千金','给我端茶倒水');
> console.log(girl3.Cando());
> ```
以上就是动态原型模式，在我们 ⑪ 组合构造函数+原型模式上，对代码做了一个封装，让代码更加整体化一点，但需要做个判断，不要让原型函数不停的初始化，避免浪费资源。 <br/>


我们上面讲的模式在开发中，已经够用了，推荐使用 ⑪ 组合构造函数+原型模式（不介意代码封装），和 ⑫ 动态原型模式（讲⑪ 的代码封装到了一起），如果这些模式还不能满足你，就回到我们本章一开始的模式：寄生构造函数。
### ⑬ 寄生构造函数：工厂模式 + 构造函数【备胎模式（了解）】
> 寄生构造函数，其实就是工厂模式+构造函数模式。这种模式比较通用，但不能确定对象关系，所以，在可以使用之前所说的模式时，不建议使用此模式。
> ```javascript
> //寄生构造函数：工厂模式 + 构造函数
> function Girls(looks,family){
>   let girl = new Object();
>   girl.looks = looks;
>   girl.family = family;
>   girl.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
>   return girl;
> }
> 
> let girl1 = new Girls('非常漂亮','富二代');
> console.log(girl1.Cando());
> 
> let girl2 = new Girls('长相甜美','富家千金');
> console.log(girl2.Cando());
> 
> //这种比较通用，但是不能确定对象关系，因此放在最后备用
> ```
> 在什么情况下使用寄生构造函数比较合适呢？假设要创建一个具有额外方法的引用类型。由于之前说明不建议直接 String.prototype.addstring，可以通过寄生构造的方式添加。
> ```javascript
> function myString(string) {
>   let str = new String(string);
>   str.addstring = function () {
>     return this + '，真漂亮！';
>   };
>   return str;
> }
> let text = new myString('迪丽热巴'); //比直接在引用原型添加要繁琐好多
> console.log(text.addstring());
> ```

### ⑭ 稳妥构造函数（了解即可）：在一些安全的环境中，比如禁止使用 this 和 new，就是寄生构造函数不能用new
> 这里的 this 是构造函数里不使用 this，这里的 new 是在外部实例化构造函数时不使用 new.
> ```javascript
> //稳妥构造函数
> function Girls(looks,family){
>   let girl = new Object();
>   girl.looks = looks;
>   girl.family = family;
>   girl.Cando = function(){
>     return this.looks + this.family + '给我洗衣、做饭、陪我打游戏、旅游、心疼我，事事以我为中心！';
>   }
>   return girl;
> }
> 
> let girl1 = Girls('非常漂亮','富二代');//没有用new，也可以
> console.log(girl1.Cando());
> 
> //了解即可
> ```


## III、继承
> 继承从字面意思理解，就是父亲有财产1000万，去世后儿子可以去继承这些财产自己可以用了。同样的，js中也可以继承关系。
### ① js的继承方式通过原型链完成
> ```javascript
> //这个函数里面的属性或方法可以给别的函数用
> //那这个函数就是被继承的函数，叫做超类型（父类，基类）
> function Girls(){
>    this.looks = '非常漂亮';
> }
> 
> //这个函数要继承上面的函数里面的属性和方法
> //这个函数就是继承的函数，叫做子类型（子类，派生类）
> function Loves(){
>    this.love = '洗衣做饭做家务';
> }
> 
> //操作的时候，在子类操作
> let love1 = new Loves();
> console.log(love1.love);//自己有的属性love
> //自己没有looks属性，它是属于超类型的父类的
> console.log(love1.looks);//undefined
> 
> //那么如何让looks可以打印出来，通过原型链继承
> //就是超类型（父类）new 出来的东西（实例化后的对象实例），赋值给子类型的原型属性即可
> //就是new Girls()会将Girls构造里面的信息，及原型里面的信息都交给Loves
> Loves.prototype = new Girls();
> //这样的话，Loves的原型，就得到了Girls构造函数里面的信息及Girls原型里面的信息
> let love2 = new Loves();
> console.log(love2.looks);//'非常漂亮'
> 
> 
> //可以继续构造继承
> function Family(){
>    this.family = '富二代';
> }
> Family.prototype = new Loves();
> let family1 = new Family();
> console.log(family1.family);//'富二代'
> console.log(family1.love);//'洗衣做饭做家务'
> console.log(family1.looks);//'非常漂亮'
> 
> 
> //以上通过子类的原型不断继承父类构造函数和父类原型里面的信息的方式，像个链条一样
> //称之为：原型链
> //js是通过 原型链的这种方式实现的
> ```

### ② 继承父类属性方法的继承顺序：就近原则（实例化-->构造函数实例属性方法-->原型属性方法）
> ```javascript
> //继承属性方法顺序
> function Girls() { 
>   this.looks = '非常漂亮';
> }
> //原型里面也有这个属性
> Girls.prototype.looks = '天使面容';
> 
> function Loves(){
>   this.love = '洗衣做饭做家务';
> }
> Loves.prototype = new Girls();//原型链继承
> 
> let love1 = new Loves();
> //跟我们前面一样的原则，就近原则： 实例化--->构造函数实例属性---->原型属性
> // love1.looks = '萝莉型';
> console.log(love1.looks);//'非常漂亮'
> ```

### ③ 继承后的实例从属关系
> 以上原型链继承还缺少一环，那就是 Obejct，所有的构造函数都继承自 Obejct。而继承 Object 是自动完成的，并不需要程序员手动继承。
> ```javascript
> //继承后的实例从属关系
> function Girls() { 
>   this.looks = '非常漂亮';
> }
> //原型里面也有这个属性
> Girls.prototype.looks = '天使面容';
> 
> function Loves(){
>   this.love = '洗衣做饭做家务';
> }
> Loves.prototype = new Girls();//原型链继承
> let love1 = new Loves();
> 
> //看一下从属关系
> //1. 子类型实例化的对象从属于自己的类型
> console.log(love1 instanceof Loves);//true
> //2. 子类型实例化的对象从属于它的超类型（父类）
> console.log(love1 instanceof Girls);//true
> //3. 构造函数都继承自 Obejct，继承 Object 是自动完成的，并不需要程序员手动继承
> console.log(love1 instanceof Object);//true
> ```









<br/><br/><br/><br/><br/><br/>

## 【第二学期第2季课程】其它章节
### [章节1.课程介绍](/secondless/w-b '章节1.课程介绍')
<!-- <LessList  /> -->
### [章节2.面向对象与原型](/secondless/w-b/面向对象与原型 '章节2.面向对象与原型')

## 其它学期课程
### [第一学期（学习顺序：01）](/aboutless.html '第一学期课程')
> 第一学期课程专为零基础的学员定制录制的，纯html+css做企业网站的网页，主讲html和css的相关基础知识，flex布局相关知识，封装css基础样式库，引入字体图标及网页开发基础布局思维，完成企业网站网页的开发过程。<br/><br/>
<b><a href="https://study.163.com/course/courseMain.htm?courseId=1213374826&share=2&shareId=480000002289674" target="_blank">[第一学期学习视频]</a>
</b>

### [第二学期【第1季】（学习顺序：02）](/secondless/w-a '第二学期第1季课程')
> 主讲JavaScript的基础，建议所有学员观看。<br/>
<b>
   <a href="/secondless/w-a.html" target="_blank">[第1季学习文档]</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   <a style="margin-left:20px;">[第1季学习视频]</a>
</b>

### [第二学期【第2季】（学习顺序：03）](/secondless/w-b '第二学期第2季课程')
> JavaScript中的面向对象，类，ajax，封装js库过渡到jQuery， vue.js基础配置网站页面，建议所有学员观看。<br/>
<b>
   <a href="/secondless/w-b.html" target="_blank">[第2季学习文档]</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   <a style="margin-left:20px;">[第2季学习视频]</a>
</b>